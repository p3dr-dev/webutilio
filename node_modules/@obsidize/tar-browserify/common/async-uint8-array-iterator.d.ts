import { AsyncUint8ArrayLike } from './async-uint8-array';
/**
 * Read result when `AsyncUint8ArrayIterator.next()` succeeds.
 */
export interface AsyncUint8ArrayBlock {
    /**
     * The input object that has provided the data from some external mechanism
     */
    source: AsyncUint8ArrayLike;
    /**
     * The value read from `source`
     */
    buffer: Uint8Array;
    /**
     * The absolute offset in `source` that `buffer` was read from.
     * This will be in range [0, source.byteLength]
     */
    offset: number;
}
/**
 * Generalized symbol / type for AsyncUint8ArrayIterator
 */
export type AsyncUint8ArrayIteratorLike = AsyncIterableIterator<AsyncUint8ArrayBlock>;
/**
 * Valid input types for an AsyncUint8ArrayIterator instance
 */
export type AsyncUint8ArrayIteratorInput = Uint8Array | AsyncUint8ArrayLike;
export interface AsyncUint8ArrayIteratorOptions {
    /**
     * Custom block size to read chunks in.
     * Must be a multiple of `SECTOR_SIZE`.
     * Cannot be smaller than `SECTOR_SIZE`.
     */
    blockSize: number;
}
/**
 * Generalized abstraction for pulling in raw octet data, whether its
 * over the network or from disk or in memory.
 *
 * This is designed to reduce general complexity / fragmentation
 * when parsing out tar sectors by forcing every input type to adhere to
 * the same streaming interface.
 */
export declare class AsyncUint8ArrayIterator implements AsyncUint8ArrayIteratorLike {
    private readonly mInput;
    private readonly blockSize;
    private mOffset;
    constructor(input: AsyncUint8ArrayIteratorInput, options?: Partial<AsyncUint8ArrayIteratorOptions>);
    [Symbol.asyncIterator](): AsyncUint8ArrayIteratorLike;
    get input(): AsyncUint8ArrayLike;
    get byteLength(): number;
    get currentOffset(): number;
    tryNext(): Promise<Uint8Array | null>;
    /**
     * Grab the next `blockSize` chunk of data from the input.
     * See `AsyncIterableIterator` for more info.
     */
    next(): Promise<IteratorResult<AsyncUint8ArrayBlock>>;
}
