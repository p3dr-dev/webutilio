import { Constants } from './constants';
export var TarUtility;
(function (TarUtility) {
    function isNumber(value) {
        return typeof value === 'number' && !Number.isNaN(value);
    }
    TarUtility.isNumber = isNumber;
    function isString(value) {
        return typeof value === 'string';
    }
    TarUtility.isString = isString;
    function isUndefined(value) {
        return typeof value === 'undefined';
    }
    TarUtility.isUndefined = isUndefined;
    function isObject(value) {
        return typeof value === 'object' && value !== null;
    }
    TarUtility.isObject = isObject;
    function isDefined(value) {
        return !isUndefined(value);
    }
    TarUtility.isDefined = isDefined;
    function isPopulatedString(value) {
        return isString(value) && value.length > 0;
    }
    TarUtility.isPopulatedString = isPopulatedString;
    function isUint8Array(value) {
        return !!(value && value instanceof Uint8Array);
    }
    TarUtility.isUint8Array = isUint8Array;
    function sizeofUint8Array(value) {
        return isUint8Array(value) ? value.byteLength : 0;
    }
    TarUtility.sizeofUint8Array = sizeofUint8Array;
    function encodeString(input) {
        return isPopulatedString(input) ? new TextEncoder().encode(input) : new Uint8Array(0);
    }
    TarUtility.encodeString = encodeString;
    function decodeString(input) {
        return isUint8Array(input) ? new TextDecoder().decode(input) : '';
    }
    TarUtility.decodeString = decodeString;
    function generateChecksum(input) {
        return isUint8Array(input) ? input.reduce((a, b) => a + b, 0) : 0;
    }
    TarUtility.generateChecksum = generateChecksum;
    function clamp(value, min, max) {
        return Math.max(min, Math.min(value, max));
    }
    TarUtility.clamp = clamp;
    function advanceSectorOffset(currentOffset, maxOffset) {
        return Math.min(maxOffset, advanceSectorOffsetUnclamped(currentOffset));
    }
    TarUtility.advanceSectorOffset = advanceSectorOffset;
    function advanceSectorOffsetUnclamped(currentOffset) {
        return (1 + Math.floor(currentOffset / Constants.SECTOR_SIZE)) * Constants.SECTOR_SIZE;
    }
    TarUtility.advanceSectorOffsetUnclamped = advanceSectorOffsetUnclamped;
    function roundUpSectorOffset(currentOffset) {
        return Math.ceil(currentOffset / Constants.SECTOR_SIZE) * Constants.SECTOR_SIZE;
    }
    TarUtility.roundUpSectorOffset = roundUpSectorOffset;
    function getSectorOffsetDelta(currentOffset) {
        return roundUpSectorOffset(currentOffset) - currentOffset;
    }
    TarUtility.getSectorOffsetDelta = getSectorOffsetDelta;
    function parseIntOctal(input) {
        return parseIntSafe(input, Constants.OCTAL_RADIX);
    }
    TarUtility.parseIntOctal = parseIntOctal;
    function dateTimeToUstar(dateTime) {
        return Math.floor(parseIntSafe(dateTime) / 1000);
    }
    TarUtility.dateTimeToUstar = dateTimeToUstar;
    function ustarTimeToDate(ustarTime) {
        return Math.floor(parseIntSafe(ustarTime)) * 1000;
    }
    TarUtility.ustarTimeToDate = ustarTimeToDate;
    function sanitizeDateTimeAsUstar(dateTime) {
        return ustarTimeToDate(dateTimeToUstar(dateTime));
    }
    TarUtility.sanitizeDateTimeAsUstar = sanitizeDateTimeAsUstar;
    function getUstarTimestamp() {
        return sanitizeDateTimeAsUstar(Date.now());
    }
    TarUtility.getUstarTimestamp = getUstarTimestamp;
    function paxTimeToDate(paxTime) {
        return Math.floor(paxTime * 1000);
    }
    TarUtility.paxTimeToDate = paxTimeToDate;
    function paxTimeToUstar(paxTime) {
        return Math.floor(paxTime); // USTAR is just the seconds part of PAX as an integer
    }
    TarUtility.paxTimeToUstar = paxTimeToUstar;
    function getDebugHexString(v) {
        if (!isUint8Array(v))
            return '';
        return Array.from(v)
            .map((b) => b.toString(16).padStart(2, '0').toUpperCase())
            .join(' ');
    }
    TarUtility.getDebugHexString = getDebugHexString;
    function getDebugBufferJson(v) {
        return {
            byteLength: v?.byteLength ?? 0,
            content: TarUtility.getDebugHexString(v),
        };
    }
    TarUtility.getDebugBufferJson = getDebugBufferJson;
    function removeTrailingZeros(str) {
        const pattern = /^([^\0]*)[\0]*$/;
        const result = pattern.exec(str);
        return result ? result[1] : str;
    }
    TarUtility.removeTrailingZeros = removeTrailingZeros;
    function parseIntSafe(value, radix = 10, defaultValue = 0) {
        if (isNumber(value))
            return Math.floor(value);
        const parsed = parseInt(value, radix);
        return isNumber(parsed) ? parsed : defaultValue;
    }
    TarUtility.parseIntSafe = parseIntSafe;
    function parseFloatSafe(value, defaultValue = 0) {
        if (isNumber(value))
            return value;
        const parsed = parseFloat(value);
        return isNumber(parsed) ? parsed : defaultValue;
    }
    TarUtility.parseFloatSafe = parseFloatSafe;
    function cloneUint8Array(source, start, end) {
        if (!isUint8Array(source))
            return new Uint8Array(0);
        const sliced = source.slice(start, end);
        const bytes = Array.from(sliced);
        return Uint8Array.from(bytes);
    }
    TarUtility.cloneUint8Array = cloneUint8Array;
    function concatUint8Arrays(a, b) {
        if (!isUint8Array(b))
            return a;
        if (!isUint8Array(a))
            return b;
        const aLength = a.byteLength;
        const bLength = b.byteLength;
        const result = new Uint8Array(aLength + bLength);
        if (aLength > 0)
            result.set(a, 0);
        if (bLength > 0)
            result.set(b, aLength);
        return result;
    }
    TarUtility.concatUint8Arrays = concatUint8Arrays;
})(TarUtility || (TarUtility = {}));
