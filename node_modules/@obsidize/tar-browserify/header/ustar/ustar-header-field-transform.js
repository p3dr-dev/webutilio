import { Constants } from '../../common/constants';
import { TarUtility } from '../../common/tar-utility';
import { UstarHeaderFieldType } from './ustar-header-field-type';
export var UstarHeaderFieldTransformType;
(function (UstarHeaderFieldTransformType) {
    function serializeIntegerOctalToString(value, maxLength) {
        return TarUtility.parseIntSafe(value)
            .toString(Constants.OCTAL_RADIX)
            .padStart(maxLength, '0')
            .substring(0, maxLength);
    }
    function serializeIntegerOctalWithSuffix(value, fieldLength, suffix) {
        const adjustedLength = Math.max(0, fieldLength - 1 - suffix.length);
        // USTAR docs indicate that value length needs to be 1 less than actual field size.
        // We also need to allow for suffixes... because random white spaces.
        const serializedString = serializeIntegerOctalToString(value, adjustedLength) + suffix;
        return TarUtility.encodeString(serializedString);
    }
    function getScopedBytes(input, fieldLength, offset) {
        return input.slice(offset, offset + fieldLength);
    }
    function serializeAscii(input, fieldLength) {
        return TarUtility.encodeString(String(input).substring(0, fieldLength));
    }
    function deserializeAscii(input, fieldLength, offset) {
        const bytes = getScopedBytes(input, fieldLength, offset);
        return TarUtility.decodeString(bytes);
    }
    function serializeAsciiPadded(input, fieldLength) {
        input = String(input);
        if (input.length > fieldLength) {
            return TarUtility.encodeString(input.substring(0, fieldLength - 1) + '\0');
        }
        return TarUtility.encodeString(input.padEnd(fieldLength, '\0'));
    }
    function deserializeAsciiPadded(input, fieldLength, offset) {
        const bytes = getScopedBytes(input, fieldLength, offset);
        return TarUtility.removeTrailingZeros(TarUtility.decodeString(bytes));
    }
    function serializeIntegerOctal(value, fieldLength) {
        return serializeIntegerOctalWithSuffix(value, fieldLength, ' ');
    }
    function deserializeIntegerOctal(input, fieldLength, offset) {
        const bytes = getScopedBytes(input, fieldLength, offset);
        return TarUtility.parseIntSafe(TarUtility.decodeString(bytes).trim(), Constants.OCTAL_RADIX);
    }
    function serializeIntegerOctalTimestamp(value, fieldLength) {
        return serializeIntegerOctalWithSuffix(TarUtility.dateTimeToUstar(value), fieldLength, '');
    }
    function deserializeIntegerOctalTimestamp(input, fieldLength, offset) {
        return TarUtility.ustarTimeToDate(deserializeIntegerOctal(input, fieldLength, offset));
    }
    UstarHeaderFieldTransformType.ASCII = Object.freeze({
        serialize: serializeAscii,
        deserialize: deserializeAscii,
    });
    UstarHeaderFieldTransformType.ASCII_PADDED_END = Object.freeze({
        serialize: serializeAsciiPadded,
        deserialize: deserializeAsciiPadded,
    });
    UstarHeaderFieldTransformType.INTEGER_OCTAL = Object.freeze({
        serialize: serializeIntegerOctal,
        deserialize: deserializeIntegerOctal,
    });
    UstarHeaderFieldTransformType.INTEGER_OCTAL_TIMESTAMP = Object.freeze({
        serialize: serializeIntegerOctalTimestamp,
        deserialize: deserializeIntegerOctalTimestamp,
    });
    function from(fieldType) {
        switch (fieldType) {
            case UstarHeaderFieldType.ASCII:
                return UstarHeaderFieldTransformType.ASCII;
            case UstarHeaderFieldType.ASCII_PADDED_END:
                return UstarHeaderFieldTransformType.ASCII_PADDED_END;
            case UstarHeaderFieldType.INTEGER_OCTAL:
                return UstarHeaderFieldTransformType.INTEGER_OCTAL;
            case UstarHeaderFieldType.INTEGER_OCTAL_TIMESTAMP:
                return UstarHeaderFieldTransformType.INTEGER_OCTAL_TIMESTAMP;
            default:
                return undefined;
        }
    }
    UstarHeaderFieldTransformType.from = from;
})(UstarHeaderFieldTransformType || (UstarHeaderFieldTransformType = {}));
