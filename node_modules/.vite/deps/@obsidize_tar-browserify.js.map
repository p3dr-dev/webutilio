{
  "version": 3,
  "sources": ["../../@obsidize/tar-browserify/common/async-uint8-array.js", "../../@obsidize/tar-browserify/common/constants.js", "../../@obsidize/tar-browserify/common/tar-utility.js", "../../@obsidize/tar-browserify/common/async-uint8-array-iterator.js", "../../@obsidize/tar-browserify/header/ustar/ustar-header-field-type.js", "../../@obsidize/tar-browserify/header/ustar/ustar-header-field-transform.js", "../../@obsidize/tar-browserify/header/ustar/ustar-header-field.js", "../../@obsidize/tar-browserify/header/pax/pax-header-key.js", "../../@obsidize/tar-browserify/header/pax/pax-header-segment.js", "../../@obsidize/tar-browserify/header/pax/pax-header-utility.js", "../../@obsidize/tar-browserify/header/pax/pax-header.js", "../../@obsidize/tar-browserify/header/ustar/ustar-header-link-indicator-type.js", "../../@obsidize/tar-browserify/header/tar-header-utility.js", "../../@obsidize/tar-browserify/header/ustar/ustar-header.js", "../../@obsidize/tar-browserify/header/tar-header.js", "../../@obsidize/tar-browserify/archive/archive-entry.js", "../../@obsidize/tar-browserify/archive/archive-reader.js", "../../@obsidize/tar-browserify/archive/archive-writer.js", "../../@obsidize/tar-browserify/archive/archive.js"],
  "sourcesContent": ["/**\r\n * Built-in wrapper for basic in-memory buffers so they\r\n * can be transposed to fit the shared `AsyncUint8ArrayLike` format.\r\n */\r\nexport class InMemoryAsyncUint8Array {\r\n    constructor(input) {\r\n        this.input = input;\r\n    }\r\n    get byteLength() {\r\n        return this.input.byteLength;\r\n    }\r\n    read(offset, length) {\r\n        const max = this.input.byteLength;\r\n        const start = Math.min(offset, max);\r\n        const end = Math.min(start + length, max);\r\n        return Promise.resolve(this.input.slice(start, end));\r\n    }\r\n}\r\n", "export var Constants;\r\n(function (Constants) {\r\n    Constants.SECTOR_SIZE = 512;\r\n    Constants.OCTAL_RADIX = 8;\r\n    Constants.USTAR_TAG = 'ustar'; // HEX = 75 73 74 61 72\r\n    Constants.USTAR_INDICATOR_VALUE = `${Constants.USTAR_TAG}\\0`;\r\n    Constants.USTAR_VERSION_VALUE = '00';\r\n    Constants.HEADER_SIZE = Constants.SECTOR_SIZE;\r\n    Constants.FILE_MODE_DEFAULT = 511; // '777' octal\r\n    Constants.TERMINAL_PADDING_SIZE = Constants.SECTOR_SIZE * 2;\r\n    Constants.PAX_HEADER_PREFIX = 'PaxHeader';\r\n})(Constants || (Constants = {}));\r\n", "import { Constants } from './constants';\r\nexport var TarUtility;\r\n(function (TarUtility) {\r\n    function isNumber(value) {\r\n        return typeof value === 'number' && !Number.isNaN(value);\r\n    }\r\n    TarUtility.isNumber = isNumber;\r\n    function isString(value) {\r\n        return typeof value === 'string';\r\n    }\r\n    TarUtility.isString = isString;\r\n    function isUndefined(value) {\r\n        return typeof value === 'undefined';\r\n    }\r\n    TarUtility.isUndefined = isUndefined;\r\n    function isObject(value) {\r\n        return typeof value === 'object' && value !== null;\r\n    }\r\n    TarUtility.isObject = isObject;\r\n    function isDefined(value) {\r\n        return !isUndefined(value);\r\n    }\r\n    TarUtility.isDefined = isDefined;\r\n    function isPopulatedString(value) {\r\n        return isString(value) && value.length > 0;\r\n    }\r\n    TarUtility.isPopulatedString = isPopulatedString;\r\n    function isUint8Array(value) {\r\n        return !!(value && value instanceof Uint8Array);\r\n    }\r\n    TarUtility.isUint8Array = isUint8Array;\r\n    function sizeofUint8Array(value) {\r\n        return isUint8Array(value) ? value.byteLength : 0;\r\n    }\r\n    TarUtility.sizeofUint8Array = sizeofUint8Array;\r\n    function encodeString(input) {\r\n        return isPopulatedString(input) ? new TextEncoder().encode(input) : new Uint8Array(0);\r\n    }\r\n    TarUtility.encodeString = encodeString;\r\n    function decodeString(input) {\r\n        return isUint8Array(input) ? new TextDecoder().decode(input) : '';\r\n    }\r\n    TarUtility.decodeString = decodeString;\r\n    function generateChecksum(input) {\r\n        return isUint8Array(input) ? input.reduce((a, b) => a + b, 0) : 0;\r\n    }\r\n    TarUtility.generateChecksum = generateChecksum;\r\n    function clamp(value, min, max) {\r\n        return Math.max(min, Math.min(value, max));\r\n    }\r\n    TarUtility.clamp = clamp;\r\n    function advanceSectorOffset(currentOffset, maxOffset) {\r\n        return Math.min(maxOffset, advanceSectorOffsetUnclamped(currentOffset));\r\n    }\r\n    TarUtility.advanceSectorOffset = advanceSectorOffset;\r\n    function advanceSectorOffsetUnclamped(currentOffset) {\r\n        return (1 + Math.floor(currentOffset / Constants.SECTOR_SIZE)) * Constants.SECTOR_SIZE;\r\n    }\r\n    TarUtility.advanceSectorOffsetUnclamped = advanceSectorOffsetUnclamped;\r\n    function roundUpSectorOffset(currentOffset) {\r\n        return Math.ceil(currentOffset / Constants.SECTOR_SIZE) * Constants.SECTOR_SIZE;\r\n    }\r\n    TarUtility.roundUpSectorOffset = roundUpSectorOffset;\r\n    function getSectorOffsetDelta(currentOffset) {\r\n        return roundUpSectorOffset(currentOffset) - currentOffset;\r\n    }\r\n    TarUtility.getSectorOffsetDelta = getSectorOffsetDelta;\r\n    function parseIntOctal(input) {\r\n        return parseIntSafe(input, Constants.OCTAL_RADIX);\r\n    }\r\n    TarUtility.parseIntOctal = parseIntOctal;\r\n    function dateTimeToUstar(dateTime) {\r\n        return Math.floor(parseIntSafe(dateTime) / 1000);\r\n    }\r\n    TarUtility.dateTimeToUstar = dateTimeToUstar;\r\n    function ustarTimeToDate(ustarTime) {\r\n        return Math.floor(parseIntSafe(ustarTime)) * 1000;\r\n    }\r\n    TarUtility.ustarTimeToDate = ustarTimeToDate;\r\n    function sanitizeDateTimeAsUstar(dateTime) {\r\n        return ustarTimeToDate(dateTimeToUstar(dateTime));\r\n    }\r\n    TarUtility.sanitizeDateTimeAsUstar = sanitizeDateTimeAsUstar;\r\n    function getUstarTimestamp() {\r\n        return sanitizeDateTimeAsUstar(Date.now());\r\n    }\r\n    TarUtility.getUstarTimestamp = getUstarTimestamp;\r\n    function paxTimeToDate(paxTime) {\r\n        return Math.floor(paxTime * 1000);\r\n    }\r\n    TarUtility.paxTimeToDate = paxTimeToDate;\r\n    function paxTimeToUstar(paxTime) {\r\n        return Math.floor(paxTime); // USTAR is just the seconds part of PAX as an integer\r\n    }\r\n    TarUtility.paxTimeToUstar = paxTimeToUstar;\r\n    function getDebugHexString(v) {\r\n        if (!isUint8Array(v))\r\n            return '';\r\n        return Array.from(v)\r\n            .map((b) => b.toString(16).padStart(2, '0').toUpperCase())\r\n            .join(' ');\r\n    }\r\n    TarUtility.getDebugHexString = getDebugHexString;\r\n    function getDebugBufferJson(v) {\r\n        return {\r\n            byteLength: v?.byteLength ?? 0,\r\n            content: TarUtility.getDebugHexString(v),\r\n        };\r\n    }\r\n    TarUtility.getDebugBufferJson = getDebugBufferJson;\r\n    function removeTrailingZeros(str) {\r\n        const pattern = /^([^\\0]*)[\\0]*$/;\r\n        const result = pattern.exec(str);\r\n        return result ? result[1] : str;\r\n    }\r\n    TarUtility.removeTrailingZeros = removeTrailingZeros;\r\n    function parseIntSafe(value, radix = 10, defaultValue = 0) {\r\n        if (isNumber(value))\r\n            return Math.floor(value);\r\n        const parsed = parseInt(value, radix);\r\n        return isNumber(parsed) ? parsed : defaultValue;\r\n    }\r\n    TarUtility.parseIntSafe = parseIntSafe;\r\n    function parseFloatSafe(value, defaultValue = 0) {\r\n        if (isNumber(value))\r\n            return value;\r\n        const parsed = parseFloat(value);\r\n        return isNumber(parsed) ? parsed : defaultValue;\r\n    }\r\n    TarUtility.parseFloatSafe = parseFloatSafe;\r\n    function cloneUint8Array(source, start, end) {\r\n        if (!isUint8Array(source))\r\n            return new Uint8Array(0);\r\n        const sliced = source.slice(start, end);\r\n        const bytes = Array.from(sliced);\r\n        return Uint8Array.from(bytes);\r\n    }\r\n    TarUtility.cloneUint8Array = cloneUint8Array;\r\n    function concatUint8Arrays(a, b) {\r\n        if (!isUint8Array(b))\r\n            return a;\r\n        if (!isUint8Array(a))\r\n            return b;\r\n        const aLength = a.byteLength;\r\n        const bLength = b.byteLength;\r\n        const result = new Uint8Array(aLength + bLength);\r\n        if (aLength > 0)\r\n            result.set(a, 0);\r\n        if (bLength > 0)\r\n            result.set(b, aLength);\r\n        return result;\r\n    }\r\n    TarUtility.concatUint8Arrays = concatUint8Arrays;\r\n})(TarUtility || (TarUtility = {}));\r\n", "import { InMemoryAsyncUint8Array } from './async-uint8-array';\r\nimport { Constants } from './constants';\r\nimport { TarUtility } from './tar-utility';\r\nfunction sanitizeOptions(options) {\r\n    return Object.assign({\r\n        blockSize: Constants.SECTOR_SIZE * 16, // 8Kb\r\n    }, options);\r\n}\r\nconst MIN_BLOCK_SIZE = Constants.SECTOR_SIZE;\r\nconst MAX_BLOCK_SIZE = Constants.SECTOR_SIZE * 10000;\r\n/**\r\n * Generalized abstraction for pulling in raw octet data, whether its\r\n * over the network or from disk or in memory.\r\n *\r\n * This is designed to reduce general complexity / fragmentation\r\n * when parsing out tar sectors by forcing every input type to adhere to\r\n * the same streaming interface.\r\n */\r\nexport class AsyncUint8ArrayIterator {\r\n    constructor(input, options = {}) {\r\n        this.mOffset = 0;\r\n        this.mInput = TarUtility.isUint8Array(input) ? new InMemoryAsyncUint8Array(input) : input;\r\n        let { blockSize } = sanitizeOptions(options);\r\n        blockSize = TarUtility.clamp(blockSize, MIN_BLOCK_SIZE, MAX_BLOCK_SIZE);\r\n        blockSize = TarUtility.roundUpSectorOffset(blockSize);\r\n        this.blockSize = blockSize;\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return this;\r\n    }\r\n    get input() {\r\n        return this.mInput;\r\n    }\r\n    get byteLength() {\r\n        return this.mInput.byteLength;\r\n    }\r\n    get currentOffset() {\r\n        return this.mOffset;\r\n    }\r\n    async tryNext() {\r\n        const result = await this.next();\r\n        return result?.value?.buffer ?? null;\r\n    }\r\n    /**\r\n     * Grab the next `blockSize` chunk of data from the input.\r\n     * See `AsyncIterableIterator` for more info.\r\n     */\r\n    async next() {\r\n        const source = this.input;\r\n        const offset = this.currentOffset;\r\n        const length = this.byteLength;\r\n        if (offset >= length) {\r\n            return { done: true, value: null };\r\n        }\r\n        const targetLength = Math.min(this.blockSize, length - offset);\r\n        const buffer = await source.read(offset, targetLength);\r\n        this.mOffset += targetLength;\r\n        return { done: false, value: { source, buffer, offset } };\r\n    }\r\n}\r\n", "/**\r\n * Determines how a tar header field is interpreted to and from a Uint8Array.\r\n */\r\nexport var UstarHeaderFieldType;\r\n(function (UstarHeaderFieldType) {\r\n    /**\r\n     * Bytes interpreted as char codes.\r\n     */\r\n    UstarHeaderFieldType[\"ASCII\"] = \"ASCII\";\r\n    /**\r\n     * Bytes interpreted as char codes with spaces and trailing NUL characters.\r\n     *\r\n     * @example\r\n     * 'Test File Name.txt\\0\\0\\0\\0\\0\\0\\0....'\r\n     */\r\n    UstarHeaderFieldType[\"ASCII_PADDED_END\"] = \"ASCII_PADDED_END\";\r\n    /**\r\n     * Bytes interpreted as a padded ascii octal number (i.e. ascii in range ['0' - '7']).\r\n     * USTAR format dictates that all octal integer values of this type should be front-padded with zeroes.\r\n     *\r\n     * @example\r\n     * '0000232 ' // (equates to decimal 1234)\r\n     */\r\n    UstarHeaderFieldType[\"INTEGER_OCTAL\"] = \"INTEGER_OCTAL\";\r\n    /**\r\n     * Special flavor of an integer octal that also transforms the\r\n     * value by 1000x to add the milliseconds frame for a Date value.\r\n     */\r\n    UstarHeaderFieldType[\"INTEGER_OCTAL_TIMESTAMP\"] = \"INTEGER_OCTAL_TIMESTAMP\";\r\n})(UstarHeaderFieldType || (UstarHeaderFieldType = {}));\r\n", "import { Constants } from '../../common/constants';\r\nimport { TarUtility } from '../../common/tar-utility';\r\nimport { UstarHeaderFieldType } from './ustar-header-field-type';\r\nexport var UstarHeaderFieldTransformType;\r\n(function (UstarHeaderFieldTransformType) {\r\n    function serializeIntegerOctalToString(value, maxLength) {\r\n        return TarUtility.parseIntSafe(value)\r\n            .toString(Constants.OCTAL_RADIX)\r\n            .padStart(maxLength, '0')\r\n            .substring(0, maxLength);\r\n    }\r\n    function serializeIntegerOctalWithSuffix(value, fieldLength, suffix) {\r\n        const adjustedLength = Math.max(0, fieldLength - 1 - suffix.length);\r\n        // USTAR docs indicate that value length needs to be 1 less than actual field size.\r\n        // We also need to allow for suffixes... because random white spaces.\r\n        const serializedString = serializeIntegerOctalToString(value, adjustedLength) + suffix;\r\n        return TarUtility.encodeString(serializedString);\r\n    }\r\n    function getScopedBytes(input, fieldLength, offset) {\r\n        return input.slice(offset, offset + fieldLength);\r\n    }\r\n    function serializeAscii(input, fieldLength) {\r\n        return TarUtility.encodeString(String(input).substring(0, fieldLength));\r\n    }\r\n    function deserializeAscii(input, fieldLength, offset) {\r\n        const bytes = getScopedBytes(input, fieldLength, offset);\r\n        return TarUtility.decodeString(bytes);\r\n    }\r\n    function serializeAsciiPadded(input, fieldLength) {\r\n        input = String(input);\r\n        if (input.length > fieldLength) {\r\n            return TarUtility.encodeString(input.substring(0, fieldLength - 1) + '\\0');\r\n        }\r\n        return TarUtility.encodeString(input.padEnd(fieldLength, '\\0'));\r\n    }\r\n    function deserializeAsciiPadded(input, fieldLength, offset) {\r\n        const bytes = getScopedBytes(input, fieldLength, offset);\r\n        return TarUtility.removeTrailingZeros(TarUtility.decodeString(bytes));\r\n    }\r\n    function serializeIntegerOctal(value, fieldLength) {\r\n        return serializeIntegerOctalWithSuffix(value, fieldLength, ' ');\r\n    }\r\n    function deserializeIntegerOctal(input, fieldLength, offset) {\r\n        const bytes = getScopedBytes(input, fieldLength, offset);\r\n        return TarUtility.parseIntSafe(TarUtility.decodeString(bytes).trim(), Constants.OCTAL_RADIX);\r\n    }\r\n    function serializeIntegerOctalTimestamp(value, fieldLength) {\r\n        return serializeIntegerOctalWithSuffix(TarUtility.dateTimeToUstar(value), fieldLength, '');\r\n    }\r\n    function deserializeIntegerOctalTimestamp(input, fieldLength, offset) {\r\n        return TarUtility.ustarTimeToDate(deserializeIntegerOctal(input, fieldLength, offset));\r\n    }\r\n    UstarHeaderFieldTransformType.ASCII = Object.freeze({\r\n        serialize: serializeAscii,\r\n        deserialize: deserializeAscii,\r\n    });\r\n    UstarHeaderFieldTransformType.ASCII_PADDED_END = Object.freeze({\r\n        serialize: serializeAsciiPadded,\r\n        deserialize: deserializeAsciiPadded,\r\n    });\r\n    UstarHeaderFieldTransformType.INTEGER_OCTAL = Object.freeze({\r\n        serialize: serializeIntegerOctal,\r\n        deserialize: deserializeIntegerOctal,\r\n    });\r\n    UstarHeaderFieldTransformType.INTEGER_OCTAL_TIMESTAMP = Object.freeze({\r\n        serialize: serializeIntegerOctalTimestamp,\r\n        deserialize: deserializeIntegerOctalTimestamp,\r\n    });\r\n    function from(fieldType) {\r\n        switch (fieldType) {\r\n            case UstarHeaderFieldType.ASCII:\r\n                return UstarHeaderFieldTransformType.ASCII;\r\n            case UstarHeaderFieldType.ASCII_PADDED_END:\r\n                return UstarHeaderFieldTransformType.ASCII_PADDED_END;\r\n            case UstarHeaderFieldType.INTEGER_OCTAL:\r\n                return UstarHeaderFieldTransformType.INTEGER_OCTAL;\r\n            case UstarHeaderFieldType.INTEGER_OCTAL_TIMESTAMP:\r\n                return UstarHeaderFieldTransformType.INTEGER_OCTAL_TIMESTAMP;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    UstarHeaderFieldTransformType.from = from;\r\n})(UstarHeaderFieldTransformType || (UstarHeaderFieldTransformType = {}));\r\n", "import { Constants } from '../../common/constants';\r\nimport { TarUtility } from '../../common/tar-utility';\r\nimport { UstarHeaderFieldTransformType } from './ustar-header-field-transform';\r\nimport { UstarHeaderFieldType } from './ustar-header-field-type';\r\n/**\r\n * Definitions taken from here:\r\n * https://en.wikipedia.org/wiki/Tar_(computing)\r\n */\r\nexport class UstarHeaderField {\r\n    constructor(config) {\r\n        this.name = config.name;\r\n        this.offset = config.offset;\r\n        this.size = config.size;\r\n        this.type = config.type;\r\n        this.constantValue = config.constantValue || undefined;\r\n        this.transform = UstarHeaderFieldTransformType.from(this.type);\r\n    }\r\n    static frozen(config) {\r\n        return Object.freeze(new UstarHeaderField(config));\r\n    }\r\n    static all() {\r\n        return [\r\n            UstarHeaderField.fileName,\r\n            UstarHeaderField.fileMode,\r\n            UstarHeaderField.ownerUserId,\r\n            UstarHeaderField.groupUserId,\r\n            UstarHeaderField.fileSize,\r\n            UstarHeaderField.lastModified,\r\n            UstarHeaderField.headerChecksum,\r\n            UstarHeaderField.typeFlag,\r\n            UstarHeaderField.linkedFileName,\r\n            UstarHeaderField.ustarIndicator,\r\n            UstarHeaderField.ustarVersion,\r\n            UstarHeaderField.ownerUserName,\r\n            UstarHeaderField.ownerGroupName,\r\n            UstarHeaderField.deviceMajorNumber,\r\n            UstarHeaderField.deviceMinorNumber,\r\n            UstarHeaderField.fileNamePrefix,\r\n        ];\r\n    }\r\n    static checksumSet() {\r\n        return UstarHeaderField.all().filter((v) => v !== UstarHeaderField.headerChecksum);\r\n    }\r\n    // =====================================================================\r\n    // Instance Methods\r\n    // =====================================================================\r\n    /**\r\n     * Shorthand for padding the output of `slice` into `decodeString`.\r\n     */\r\n    sliceString(input, offset) {\r\n        return TarUtility.decodeString(this.slice(input, offset));\r\n    }\r\n    /**\r\n     * @param input - a buffer of one or more complete tar sectors\r\n     * @param offset - the offset to slice from (must be a multiple of `SECTOR_SIZE`)\r\n     * @returns the slice of the given input Uint8Array that this field resides in.\r\n     */\r\n    slice(input, offset = 0) {\r\n        if (!TarUtility.isUint8Array(input)) {\r\n            return new Uint8Array(0);\r\n        }\r\n        const start = offset + this.offset;\r\n        const end = start + this.size;\r\n        return input.slice(start, end);\r\n    }\r\n    /**\r\n     * @param input - a buffer of one or more complete tar sectors\r\n     * @returns The value parsed from the input based on this field's transform type,\r\n     * or `undefined` on error.\r\n     */\r\n    deserialize(input, offset = 0) {\r\n        if (TarUtility.isUint8Array(input)) {\r\n            return this.transform.deserialize(input, this.size, offset);\r\n        }\r\n        return undefined;\r\n    }\r\n    /**\r\n     * @param input - the value to be serialized, based on this field's transform type.\r\n     * @returns the serialized value as a Uint8Array\r\n     */\r\n    serialize(input) {\r\n        const result = new Uint8Array(this.size);\r\n        const value = this.transform.serialize(input, this.size);\r\n        result.set(value, 0);\r\n        return result;\r\n    }\r\n    /**\r\n     * Runs `deserialize()` while also taking this field's offset into account.\r\n     */\r\n    readFrom(input, offset) {\r\n        return this.deserialize(input, offset + this.offset);\r\n    }\r\n    /**\r\n     * Serialize the given value and set the output bytes in the given output buffer.\r\n     * @param output - the output buffer to be written to\r\n     * @param headerOffset - the offset of the header in the output buffer to insert the update.\r\n     * \t\tNote that this field's offset will be added to the header offset when inserting.\r\n     * @param value - the value to be serialized\r\n     * @returns true if the buffer was updated\r\n     */\r\n    writeTo(output, headerOffset, value) {\r\n        headerOffset = Math.max(headerOffset, 0);\r\n        const valueBytes = this.serialize(value);\r\n        const valueByteLength = valueBytes.byteLength;\r\n        const absoluteOffset = headerOffset + this.offset;\r\n        if (valueByteLength > 0 &&\r\n            TarUtility.isUint8Array(output) &&\r\n            output.byteLength >= absoluteOffset + valueByteLength) {\r\n            output.set(valueBytes, absoluteOffset);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Calculates the checksum value for this field in the given input buffer, at the given offset.\r\n     * All field checksum values are aggregated together to form the main header checksum entry.\r\n     * @param input - the input buffer to extract a field checksum from\r\n     * @param offset - the offset of the header in the buffer (will be combined with this field's offset)\r\n     * @returns the checksum value for this specific field\r\n     */\r\n    calculateChecksum(input, offset = 0) {\r\n        let checksum = 0;\r\n        if (!TarUtility.isUint8Array(input)) {\r\n            return checksum;\r\n        }\r\n        const start = offset + this.offset;\r\n        const end = start + this.size;\r\n        for (let i = start; i < end; i++) {\r\n            checksum += input[i];\r\n        }\r\n        return checksum;\r\n    }\r\n}\r\n// =====================================================================\r\n// Legacy Fields\r\n// =====================================================================\r\nUstarHeaderField.fileName = UstarHeaderField.frozen({\r\n    name: 'fileName',\r\n    offset: 0,\r\n    size: 100,\r\n    type: UstarHeaderFieldType.ASCII_PADDED_END,\r\n});\r\nUstarHeaderField.fileMode = UstarHeaderField.frozen({\r\n    name: 'fileMode',\r\n    offset: 100,\r\n    size: 8,\r\n    type: UstarHeaderFieldType.INTEGER_OCTAL,\r\n});\r\nUstarHeaderField.ownerUserId = UstarHeaderField.frozen({\r\n    name: 'ownerUserId',\r\n    offset: 108,\r\n    size: 8,\r\n    type: UstarHeaderFieldType.INTEGER_OCTAL,\r\n});\r\nUstarHeaderField.groupUserId = UstarHeaderField.frozen({\r\n    name: 'groupUserId',\r\n    offset: 116,\r\n    size: 8,\r\n    type: UstarHeaderFieldType.INTEGER_OCTAL,\r\n});\r\nUstarHeaderField.fileSize = UstarHeaderField.frozen({\r\n    name: 'fileSize',\r\n    offset: 124,\r\n    size: 12,\r\n    type: UstarHeaderFieldType.INTEGER_OCTAL,\r\n});\r\nUstarHeaderField.lastModified = UstarHeaderField.frozen({\r\n    name: 'lastModified',\r\n    offset: 136,\r\n    size: 12,\r\n    type: UstarHeaderFieldType.INTEGER_OCTAL_TIMESTAMP,\r\n});\r\nUstarHeaderField.headerChecksum = UstarHeaderField.frozen({\r\n    name: 'headerChecksum',\r\n    offset: 148,\r\n    size: 8,\r\n    type: UstarHeaderFieldType.INTEGER_OCTAL,\r\n});\r\nUstarHeaderField.typeFlag = UstarHeaderField.frozen({\r\n    name: 'typeFlag',\r\n    offset: 156,\r\n    size: 1,\r\n    type: UstarHeaderFieldType.ASCII,\r\n});\r\nUstarHeaderField.linkedFileName = UstarHeaderField.frozen({\r\n    name: 'linkedFileName',\r\n    offset: 157,\r\n    size: 100,\r\n    type: UstarHeaderFieldType.ASCII_PADDED_END,\r\n});\r\n// =====================================================================\r\n// USTAR Fields\r\n// =====================================================================\r\nUstarHeaderField.ustarIndicator = UstarHeaderField.frozen({\r\n    name: 'ustarIndicator',\r\n    offset: 257,\r\n    size: 6,\r\n    type: UstarHeaderFieldType.ASCII,\r\n    constantValue: Constants.USTAR_INDICATOR_VALUE,\r\n});\r\nUstarHeaderField.ustarVersion = UstarHeaderField.frozen({\r\n    name: 'ustarVersion',\r\n    offset: 263,\r\n    size: 2,\r\n    type: UstarHeaderFieldType.ASCII,\r\n    constantValue: Constants.USTAR_VERSION_VALUE,\r\n});\r\nUstarHeaderField.ownerUserName = UstarHeaderField.frozen({\r\n    name: 'ownerUserName',\r\n    offset: 265,\r\n    size: 32,\r\n    type: UstarHeaderFieldType.ASCII_PADDED_END,\r\n});\r\nUstarHeaderField.ownerGroupName = UstarHeaderField.frozen({\r\n    name: 'ownerGroupName',\r\n    offset: 297,\r\n    size: 32,\r\n    type: UstarHeaderFieldType.ASCII_PADDED_END,\r\n});\r\nUstarHeaderField.deviceMajorNumber = UstarHeaderField.frozen({\r\n    name: 'deviceMajorNumber',\r\n    offset: 329,\r\n    size: 8,\r\n    type: UstarHeaderFieldType.ASCII_PADDED_END,\r\n});\r\nUstarHeaderField.deviceMinorNumber = UstarHeaderField.frozen({\r\n    name: 'deviceMinorNumber',\r\n    offset: 337,\r\n    size: 8,\r\n    type: UstarHeaderFieldType.ASCII_PADDED_END,\r\n});\r\nUstarHeaderField.fileNamePrefix = UstarHeaderField.frozen({\r\n    name: 'fileNamePrefix',\r\n    offset: 345,\r\n    size: 155,\r\n    type: UstarHeaderFieldType.ASCII_PADDED_END,\r\n});\r\n", "/**\r\n * Special keys used in the PAX format standard.\r\n * https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03\r\n */\r\nexport var PaxHeaderKey;\r\n(function (PaxHeaderKey) {\r\n    /**\r\n     * The file access time for the following file(s), equivalent to the value of the st_atime member of the stat structure for a file, as\r\n     * described by the stat() function. The access time shall be restored if the process has appropriate privileges required to do so. The\r\n     * format of the <value> shall be as described in pax Extended Header File Times.\r\n     */\r\n    PaxHeaderKey[\"ACCESS_TIME\"] = \"atime\";\r\n    /**\r\n     * The name of the character set used to encode the data in the following file(s). The entries in the following table are defined to refer to\r\n     * known standards; additional names may be agreed on between the originator and recipient.\r\n     */\r\n    PaxHeaderKey[\"CHARSET\"] = \"charset\";\r\n    /**\r\n     * A series of characters used as a comment. All characters in the <value> field shall be ignored by pax.\r\n     */\r\n    PaxHeaderKey[\"COMMENT\"] = \"comment\";\r\n    /**\r\n     * The group ID of the group that owns the file, expressed as a decimal number using\r\n     * digits from the ISO/IEC 646:1991 standard. This record shall override the gid\r\n     * field in the following header block(s). When used in write or copy mode,\r\n     * pax shall include a gid extended header record for each file whose group ID is greater\r\n     * than 2097151 (octal 7777777).\r\n     */\r\n    PaxHeaderKey[\"GROUP_ID\"] = \"gid\";\r\n    /**\r\n     * The group of the file(s), formatted as a group name in the group database.\r\n     * This record shall override the gid and gname fields in the following header block(s),\r\n     * and any gid extended header record. When used in read, copy, or list mode,\r\n     * pax shall translate the name from the encoding in the header record to the character\r\n     * set appropriate for the group database on the receiving system.\r\n     * If any of the characters cannot be translated, and if neither the -o invalid=UTF-8 option nor\r\n     * the -o invalid=binary option is specified, the results are implementation-defined.\r\n     * When used in write or copy mode, pax shall include a gname extended header\r\n     * record for each file whose group name cannot be represented entirely\r\n     * with the letters and digits of the portable character set.\r\n     */\r\n    PaxHeaderKey[\"GROUP_NAME\"] = \"gname\";\r\n    /**\r\n     * The name of the character set used to encode the value field of the\r\n     * gname, linkpath, path, and uname pax extended header records. The entries in the following\r\n     * table are defined to refer to known standards;\r\n     * additional names may be agreed between the originator and the recipient.\r\n     */\r\n    PaxHeaderKey[\"HDR_CHARSET\"] = \"hdrcharset\";\r\n    /**\r\n     * The pathname of a link being created to another file, of any type, previously archived.\r\n     * This record shall override the linkname field in the following ustar header block(s).\r\n     * The following ustar header block shall determine the type of link created.\r\n     * If typeflag of the following header block is 1, it shall be a hard link.\r\n     * If typeflag is 2, it shall be a symbolic link and the linkpath value shall be\r\n     * the contents of the symbolic link. The pax utility shall translate the name of\r\n     * the link (contents of the symbolic link) from the encoding in the header to the\r\n     * character set appropriate for the local file system. When used in write or copy mode,\r\n     * pax shall include a linkpath extended header record for each link whose pathname cannot\r\n     * be represented entirely with the members of the portable character set other than NUL.\r\n     */\r\n    PaxHeaderKey[\"LINK_PATH\"] = \"linkpath\";\r\n    /**\r\n     * The file modification time of the following file(s),\r\n     * equivalent to the value of the st_mtime member of the stat structure for a file,\r\n     * as described in the stat() function. This record shall override the mtime field in the following header block(s).\r\n     * The modification time shall be restored if the process has appropriate privileges required to do so.\r\n     * The format of the <value> shall be as described in pax Extended Header File Times.\r\n     */\r\n    PaxHeaderKey[\"MODIFICATION_TIME\"] = \"mtime\";\r\n    /**\r\n     * The pathname of the following file(s). This record shall override the name and prefix fields in the following header block(s).\r\n     * The pax utility shall translate the pathname of the file from\r\n     * the encoding in the header to the character set appropriate for the local file system.\r\n     *\r\n     * When used in write or copy mode, pax shall include a path extended header record for each file whose\r\n     * pathname cannot be represented entirely with the members of the portable character set other than NUL.\r\n     */\r\n    PaxHeaderKey[\"PATH\"] = \"path\";\r\n    /**\r\n     * The size of the file in octets, expressed as a decimal number using digits from the ISO/IEC 646:1991 standard.\r\n     * This record shall override the size field in the following header block(s). When used in write or copy mode,\r\n     * pax shall include a size extended header record for each file with a size value greater than 8589934591 (octal 77777777777).\r\n     */\r\n    PaxHeaderKey[\"SIZE\"] = \"size\";\r\n    /**\r\n     * The user ID of the file owner, expressed as a decimal number using digits from the ISO/IEC 646:1991 standard.\r\n     * This record shall override the uid field in the following header block(s). When used in write or copy mode,\r\n     * pax shall include a uid extended header record for each file whose owner ID is greater than 2097151 (octal 7777777).\r\n     */\r\n    PaxHeaderKey[\"USER_ID\"] = \"uid\";\r\n    /**\r\n     * The owner of the following file(s), formatted as a user name in the user database.\r\n     * This record shall override the uid and uname fields in the following header block(s),\r\n     * and any uid extended header record. When used in read, copy, or list mode,\r\n     * pax shall translate the name from the encoding in the header record to the character set appropriate for\r\n     * the user database on the receiving system. If any of the characters cannot be translated,\r\n     * and if neither the -o invalid=UTF-8 option nor the -o invalid=binary option is specified,\r\n     * the results are implementation-defined. When used in write or copy mode,\r\n     * pax shall include a uname extended header record for each file whose user name cannot\r\n     * be represented entirely with the letters and digits of the portable character set.\r\n     */\r\n    PaxHeaderKey[\"USER_NAME\"] = \"uname\";\r\n})(PaxHeaderKey || (PaxHeaderKey = {}));\r\n", "import { TarUtility } from '../../common/tar-utility';\r\nconst ASCII_SPACE = 0x20;\r\nconst KEY_VALUE_SEPARATOR = '=';\r\n/**\r\n * Single segment in a PAX header block, represented by a text line with the format:\r\n * ```LENGTH KEY=VALUE\\n```\r\n */\r\nexport class PaxHeaderSegment {\r\n    constructor(mKey = '', mValue = '', mBytes = null) {\r\n        this.mKey = mKey;\r\n        this.mValue = mValue;\r\n        this.mBytes = mBytes;\r\n    }\r\n    static serialize(key, value) {\r\n        if (!key || !value) {\r\n            return new Uint8Array(0);\r\n        }\r\n        const segmentSuffix = ` ${key}=${value}\\n`;\r\n        const preCalculatedLength = segmentSuffix.length.toString().length;\r\n        let segmentLength = segmentSuffix.length + preCalculatedLength;\r\n        // Calculation caused decimal rollover, increase combined length by 1\r\n        // (e.g. including the length part caused combined length to go from something like '99' to '101')\r\n        if (segmentLength < segmentLength.toString().length + segmentSuffix.length) {\r\n            segmentLength += 1;\r\n        }\r\n        const segment = segmentLength.toString() + segmentSuffix;\r\n        return TarUtility.encodeString(segment);\r\n    }\r\n    static deserialize(bytes, offset = 0) {\r\n        if (!TarUtility.isUint8Array(bytes)) {\r\n            return null;\r\n        }\r\n        const lengthEndIndex = PaxHeaderSegment.findNextLengthEndIndex(bytes, offset);\r\n        if (lengthEndIndex < 0) {\r\n            return null;\r\n        }\r\n        const segmentLengthStr = TarUtility.decodeString(bytes.slice(offset, lengthEndIndex));\r\n        const segmentLength = parseInt(segmentLengthStr, 10);\r\n        if (isNaN(segmentLength)) {\r\n            return null;\r\n        }\r\n        const kvpStart = lengthEndIndex + 1;\r\n        const kvpEnd = offset + segmentLength;\r\n        const kvpData = TarUtility.decodeString(bytes.slice(kvpStart, kvpEnd));\r\n        const equalsDelimiterIndex = kvpData.indexOf(KEY_VALUE_SEPARATOR);\r\n        const key = kvpData.substring(0, equalsDelimiterIndex);\r\n        const value = kvpData.substring(equalsDelimiterIndex + 1).replace(/\\n$/, '');\r\n        const segmentBytes = TarUtility.cloneUint8Array(bytes, offset, offset + segmentLength);\r\n        return new PaxHeaderSegment(key, value, segmentBytes);\r\n    }\r\n    static findNextLengthEndIndex(bytes, offset) {\r\n        let lengthEnd = offset + 1;\r\n        while (lengthEnd < bytes.byteLength) {\r\n            if (bytes[lengthEnd] === ASCII_SPACE) {\r\n                return lengthEnd;\r\n            }\r\n            else {\r\n                lengthEnd += 1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    get key() {\r\n        return this.mKey;\r\n    }\r\n    get value() {\r\n        return this.mValue;\r\n    }\r\n    get bytes() {\r\n        return this.toUint8Array();\r\n    }\r\n    /**\r\n     * the value parsed as an integer, or undefined if the parse operation fails\r\n     */\r\n    get intValue() {\r\n        const parsed = parseInt(this.value);\r\n        return isNaN(parsed) ? undefined : parsed;\r\n    }\r\n    /**\r\n     * the value parsed as a float, or undefined if the parse operation fails\r\n     */\r\n    get floatValue() {\r\n        const parsed = parseFloat(this.value);\r\n        return isNaN(parsed) ? undefined : parsed;\r\n    }\r\n    toUint8Array() {\r\n        if (!TarUtility.isUint8Array(this.mBytes)) {\r\n            this.mBytes = PaxHeaderSegment.serialize(this.key, this.value);\r\n        }\r\n        return this.mBytes;\r\n    }\r\n    toJSON() {\r\n        const { key, value, bytes } = this;\r\n        const content = TarUtility.getDebugHexString(bytes);\r\n        return {\r\n            key,\r\n            value,\r\n            content,\r\n        };\r\n    }\r\n}\r\n", "import { PaxHeaderKey } from './pax-header-key';\r\nexport var PaxHeaderUtility;\r\n(function (PaxHeaderUtility) {\r\n    const knownKeys = [\r\n        PaxHeaderKey.COMMENT,\r\n        PaxHeaderKey.GROUP_ID,\r\n        PaxHeaderKey.GROUP_NAME,\r\n        PaxHeaderKey.HDR_CHARSET,\r\n        PaxHeaderKey.LINK_PATH,\r\n        PaxHeaderKey.MODIFICATION_TIME,\r\n        PaxHeaderKey.PATH,\r\n        PaxHeaderKey.SIZE,\r\n        PaxHeaderKey.USER_ID,\r\n        PaxHeaderKey.USER_NAME,\r\n    ];\r\n    function isKnownHeaderKey(key) {\r\n        return knownKeys.includes(key);\r\n    }\r\n    PaxHeaderUtility.isKnownHeaderKey = isKnownHeaderKey;\r\n})(PaxHeaderUtility || (PaxHeaderUtility = {}));\r\n", "import { Constants } from '../../common/constants';\r\nimport { TarUtility } from '../../common/tar-utility';\r\nimport { UstarHeaderField } from '../ustar/ustar-header-field';\r\nimport { PaxHeaderKey } from './pax-header-key';\r\nimport { PaxHeaderSegment } from './pax-header-segment';\r\nimport { PaxHeaderUtility } from './pax-header-utility';\r\n/**\r\n * Adds support for extended headers.\r\n * https://pubs.opengroup.org/onlinepubs/9699919799/utilities/pax.html#tag_20_92_13_03\r\n */\r\nexport class PaxHeader {\r\n    constructor(segments = []) {\r\n        this.valueMap = {};\r\n        for (const segment of segments) {\r\n            this.valueMap[segment.key] = segment;\r\n        }\r\n    }\r\n    static deserialize(buffer, offset = 0) {\r\n        const segments = PaxHeader.deserializeSegments(buffer, offset);\r\n        return new PaxHeader(segments);\r\n    }\r\n    static fromAttributes(attributes) {\r\n        const segments = PaxHeader.parseSegmentsFromAttributes(attributes);\r\n        return new PaxHeader(segments);\r\n    }\r\n    static serializeAttributes(attributes) {\r\n        const segments = PaxHeader.parseSegmentsFromAttributes(attributes);\r\n        return PaxHeader.serializeSegments(segments);\r\n    }\r\n    static parseSegmentsFromAttributes(attributes) {\r\n        if (!TarUtility.isObject(attributes)) {\r\n            return [];\r\n        }\r\n        const segments = [];\r\n        for (const [key, value] of Object.entries(attributes)) {\r\n            const strVal = TarUtility.isString(value) ? value : String(value);\r\n            segments.push(new PaxHeaderSegment(key, strVal));\r\n        }\r\n        return segments;\r\n    }\r\n    static serializeSegments(segments) {\r\n        if (!Array.isArray(segments) || segments.length <= 0) {\r\n            return new Uint8Array(0);\r\n        }\r\n        let totalLength = 0;\r\n        let segmentBuffers = [];\r\n        for (const segment of segments) {\r\n            const encodedSegment = segment.toUint8Array();\r\n            segmentBuffers.push(encodedSegment);\r\n            totalLength += encodedSegment.byteLength;\r\n        }\r\n        const resultBuffer = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const segmentBuffer of segmentBuffers) {\r\n            resultBuffer.set(segmentBuffer, offset);\r\n            offset += segmentBuffer.byteLength;\r\n        }\r\n        return resultBuffer;\r\n    }\r\n    /**\r\n     * Wraps the given file name (if necessary) with the 'PaxHeader' metadata indicator.\r\n     * If the indicator already exists in the given file name, this does nothing.\r\n     */\r\n    static wrapFileName(fileName) {\r\n        if (!TarUtility.isString(fileName) || fileName.includes(Constants.PAX_HEADER_PREFIX)) {\r\n            return fileName;\r\n        }\r\n        let sepIndex = fileName.lastIndexOf('/');\r\n        if (sepIndex >= 0) {\r\n            return PaxHeader.insertPaxAt(fileName, '/', sepIndex);\r\n        }\r\n        sepIndex = fileName.lastIndexOf('\\\\');\r\n        if (sepIndex >= 0) {\r\n            return PaxHeader.insertPaxAt(fileName, '\\\\', sepIndex);\r\n        }\r\n        return PaxHeader.makeTopLevelPrefix(fileName, '/', 0);\r\n    }\r\n    static insertPaxAt(fileName, separator, offset) {\r\n        const maxLength = UstarHeaderField.fileName.size;\r\n        if (fileName.length < maxLength) {\r\n            return fileName.substring(0, offset) + separator + Constants.PAX_HEADER_PREFIX + fileName.substring(offset);\r\n        }\r\n        return PaxHeader.makeTopLevelPrefix(fileName, '/', offset + 1);\r\n    }\r\n    static makeTopLevelPrefix(fileName, separator, offset) {\r\n        const maxLength = UstarHeaderField.fileName.size;\r\n        // Dark magic observed from existing tar files\r\n        let result = Constants.PAX_HEADER_PREFIX + separator + fileName.substring(offset);\r\n        if (result.length > maxLength) {\r\n            // Dark magic observed from existing tar files\r\n            result = result.substring(0, maxLength - 2) + '\\0\\0';\r\n        }\r\n        return result;\r\n    }\r\n    static deserializeSegments(buffer, offset) {\r\n        const result = [];\r\n        let cursor = offset;\r\n        let next = PaxHeaderSegment.deserialize(buffer, cursor);\r\n        while (next !== null) {\r\n            result.push(next);\r\n            cursor += next.bytes.byteLength;\r\n            next = PaxHeaderSegment.deserialize(buffer, cursor);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.ACCESS_TIME` for more info\r\n     */\r\n    get accessTime() {\r\n        return this.getFloat(PaxHeaderKey.ACCESS_TIME);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.CHARSET` for more info\r\n     */\r\n    get charset() {\r\n        return this.get(PaxHeaderKey.CHARSET);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.COMMENT` for more info\r\n     */\r\n    get comment() {\r\n        return this.get(PaxHeaderKey.COMMENT);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.GROUP_ID` for more info\r\n     */\r\n    get groupId() {\r\n        return this.getInt(PaxHeaderKey.GROUP_ID);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.GROUP_NAME` for more info\r\n     */\r\n    get groupName() {\r\n        return this.get(PaxHeaderKey.GROUP_NAME);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.HDR_CHARSET` for more info\r\n     */\r\n    get hdrCharset() {\r\n        return this.get(PaxHeaderKey.HDR_CHARSET);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.LINK_PATH` for more info\r\n     */\r\n    get linkPath() {\r\n        return this.get(PaxHeaderKey.LINK_PATH);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.MODIFICATION_TIME` for more info\r\n     */\r\n    get modificationTime() {\r\n        return this.getFloat(PaxHeaderKey.MODIFICATION_TIME);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.PATH` for more info\r\n     */\r\n    get path() {\r\n        return this.get(PaxHeaderKey.PATH);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.SIZE` for more info\r\n     */\r\n    get size() {\r\n        return this.getInt(PaxHeaderKey.SIZE);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.USER_ID` for more info\r\n     */\r\n    get userId() {\r\n        return this.getInt(PaxHeaderKey.USER_ID);\r\n    }\r\n    /**\r\n     * See `PaxHeaderKey.USER_NAME` for more info\r\n     */\r\n    get userName() {\r\n        return this.get(PaxHeaderKey.USER_NAME);\r\n    }\r\n    /**\r\n     * Converts modificationTime to standard javascript epoch time.\r\n     */\r\n    get lastModified() {\r\n        const mtime = this.modificationTime;\r\n        return mtime ? TarUtility.paxTimeToDate(mtime) : undefined;\r\n    }\r\n    /**\r\n     * @returns an array of the keys in this header\r\n     */\r\n    keys() {\r\n        return Object.keys(this.valueMap);\r\n    }\r\n    /**\r\n     * @returns an array of the segments in this header\r\n     */\r\n    values() {\r\n        return Object.values(this.valueMap);\r\n    }\r\n    /**\r\n     * Removes any unknown or un-standardized keys from this header.\r\n     * @returns `this` for operation chaining\r\n     */\r\n    clean() {\r\n        for (const key of this.keys()) {\r\n            if (!PaxHeaderUtility.isKnownHeaderKey(key)) {\r\n                delete this.valueMap[key];\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * @returns true if the value map of this parsed header contains the given key\r\n     */\r\n    has(key) {\r\n        return TarUtility.isDefined(this.valueMap[key]);\r\n    }\r\n    /**\r\n     * @returns the value parsed from the bytes of this header for the given key,\r\n     * or `undefined` if the key did not exist in the header.\r\n     */\r\n    get(key) {\r\n        return this.valueMap[key]?.value;\r\n    }\r\n    /**\r\n     * Parse the value for the given key as an int.\r\n     * @returns undefined if the key does not exist or the parse operation fails.\r\n     */\r\n    getInt(key) {\r\n        return this.valueMap[key]?.intValue;\r\n    }\r\n    /**\r\n     * Parse the value for the given key as a float.\r\n     * @returns undefined if the key does not exist or the parse operation fails.\r\n     */\r\n    getFloat(key) {\r\n        return this.valueMap[key]?.floatValue;\r\n    }\r\n    /**\r\n     * Serializes the underlying value map of this instance into a set of PAX sectors.\r\n     */\r\n    toUint8Array() {\r\n        return PaxHeader.serializeSegments(this.values());\r\n    }\r\n    /**\r\n     * Adds any necessary padding to the serialized output to ensure the length\r\n     * of the output is a multiple of `SECTOR_SIZE`.\r\n     *\r\n     * See `toUint8Array()` for more info.\r\n     */\r\n    toUint8ArrayPadded() {\r\n        const serializedBuffer = this.toUint8Array();\r\n        let delta = TarUtility.getSectorOffsetDelta(serializedBuffer.byteLength);\r\n        if (delta > 0) {\r\n            return TarUtility.concatUint8Arrays(serializedBuffer, new Uint8Array(delta));\r\n        }\r\n        return serializedBuffer;\r\n    }\r\n    toJSON() {\r\n        const { valueMap: attributes } = this;\r\n        const bytes = this.toUint8Array();\r\n        const buffer = TarUtility.getDebugBufferJson(bytes);\r\n        return {\r\n            attributes,\r\n            buffer,\r\n        };\r\n    }\r\n}\r\n", "/**\r\n * Sector type flag values taken from here:\r\n * (see \"Type flag field\" in wiki)\r\n *\r\n * https://en.wikipedia.org/wiki/Tar_(computing)\r\n *\r\n * Special notes from the wiki:\r\n * 'A'–'Z' - Vendor specific extensions (POSIX.1-1988)\r\n * All other values\t- Reserved for future standardization\r\n */\r\nexport var UstarHeaderLinkIndicatorType;\r\n(function (UstarHeaderLinkIndicatorType) {\r\n    /**\r\n     * Special local indicator for this module to indicate a parse failure\r\n     */\r\n    UstarHeaderLinkIndicatorType[\"UNKNOWN\"] = \"UNKNOWN\";\r\n    UstarHeaderLinkIndicatorType[\"NORMAL_FILE\"] = \"0\";\r\n    UstarHeaderLinkIndicatorType[\"NORMAL_FILE_ALT1\"] = \"\\0\";\r\n    UstarHeaderLinkIndicatorType[\"NORMAL_FILE_ALT2\"] = \"\";\r\n    UstarHeaderLinkIndicatorType[\"HARD_LINK\"] = \"1\";\r\n    UstarHeaderLinkIndicatorType[\"SYMBOLIC_LINK\"] = \"2\";\r\n    UstarHeaderLinkIndicatorType[\"CHARACTER_SPECIAL\"] = \"3\";\r\n    UstarHeaderLinkIndicatorType[\"BLOCK_SPECIAL\"] = \"4\";\r\n    UstarHeaderLinkIndicatorType[\"DIRECTORY\"] = \"5\";\r\n    UstarHeaderLinkIndicatorType[\"FIFO\"] = \"6\";\r\n    UstarHeaderLinkIndicatorType[\"CONTIGUOUS_FILE\"] = \"7\";\r\n    /**\r\n     * Global extended header with meta data (POSIX.1-2001)\r\n     */\r\n    UstarHeaderLinkIndicatorType[\"GLOBAL_EXTENDED_HEADER\"] = \"g\";\r\n    /**\r\n     * Extended header with meta data for the next file in the archive (POSIX.1-2001)\r\n     */\r\n    UstarHeaderLinkIndicatorType[\"LOCAL_EXTENDED_HEADER\"] = \"x\";\r\n})(UstarHeaderLinkIndicatorType || (UstarHeaderLinkIndicatorType = {}));\r\n", "import { Constants } from '../common/constants';\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { UstarHeaderField } from './ustar/ustar-header-field';\r\nimport { UstarHeaderLinkIndicatorType } from './ustar/ustar-header-link-indicator-type';\r\nexport var TarHeaderUtility;\r\n(function (TarHeaderUtility) {\r\n    TarHeaderUtility.CHECKSUM_SEED_STRING = ''.padStart(UstarHeaderField.headerChecksum.size, ' ');\r\n    TarHeaderUtility.CHECKSUM_SEED = TarUtility.generateChecksum(TarUtility.encodeString(TarHeaderUtility.CHECKSUM_SEED_STRING));\r\n    TarHeaderUtility.ALL_FIELDS = UstarHeaderField.all();\r\n    TarHeaderUtility.CHECKSUM_FIELDS = UstarHeaderField.checksumSet();\r\n    function isUstarSector(input, offset) {\r\n        return UstarHeaderField.ustarIndicator.sliceString(input, offset).startsWith(Constants.USTAR_TAG);\r\n    }\r\n    TarHeaderUtility.isUstarSector = isUstarSector;\r\n    function isTarHeaderLinkIndicatorTypeDirectory(type) {\r\n        return type === UstarHeaderLinkIndicatorType.DIRECTORY;\r\n    }\r\n    TarHeaderUtility.isTarHeaderLinkIndicatorTypeDirectory = isTarHeaderLinkIndicatorTypeDirectory;\r\n    function isTarHeaderLinkIndicatorTypeFile(type) {\r\n        switch (type) {\r\n            case UstarHeaderLinkIndicatorType.NORMAL_FILE:\r\n            case UstarHeaderLinkIndicatorType.NORMAL_FILE_ALT1:\r\n            case UstarHeaderLinkIndicatorType.NORMAL_FILE_ALT2:\r\n            case UstarHeaderLinkIndicatorType.CONTIGUOUS_FILE:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    TarHeaderUtility.isTarHeaderLinkIndicatorTypeFile = isTarHeaderLinkIndicatorTypeFile;\r\n    function isTarHeaderLinkIndicatorTypePax(type) {\r\n        switch (type) {\r\n            case UstarHeaderLinkIndicatorType.LOCAL_EXTENDED_HEADER:\r\n            case UstarHeaderLinkIndicatorType.GLOBAL_EXTENDED_HEADER:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    TarHeaderUtility.isTarHeaderLinkIndicatorTypePax = isTarHeaderLinkIndicatorTypePax;\r\n    /**\r\n     * Searches the given input buffer for a USTAR header tar sector, starting at the given offset.\r\n     * Returns -1 if no valid header sector is found.\r\n     */\r\n    function findNextUstarSectorOffset(input, offset = 0) {\r\n        const NOT_FOUND = -1;\r\n        if (!TarUtility.isUint8Array(input)) {\r\n            return NOT_FOUND;\r\n        }\r\n        const maxOffset = input.byteLength;\r\n        let nextOffset = Math.max(0, offset);\r\n        while (nextOffset < maxOffset && !isUstarSector(input, nextOffset)) {\r\n            nextOffset = TarUtility.advanceSectorOffset(nextOffset, maxOffset);\r\n        }\r\n        if (nextOffset < maxOffset) {\r\n            return nextOffset;\r\n        }\r\n        return NOT_FOUND;\r\n    }\r\n    TarHeaderUtility.findNextUstarSectorOffset = findNextUstarSectorOffset;\r\n})(TarHeaderUtility || (TarHeaderUtility = {}));\r\n", "import { Constants } from '../../common/constants';\r\nimport { TarUtility } from '../../common/tar-utility';\r\nimport { TarHeaderUtility } from '../tar-header-utility';\r\nimport { UstarHeaderField } from './ustar-header-field';\r\nimport { UstarHeaderLinkIndicatorType } from './ustar-header-link-indicator-type';\r\n/**\r\n * Facade over a backing Uint8Array buffer to consume/edit header data\r\n * at a specific location in the buffer.\r\n *\r\n * Does not perform any mutations or reads on creation, and\r\n * lazy loads/sets data via getters and setters.\r\n */\r\nexport class UstarHeader {\r\n    constructor(attributes = {}) {\r\n        this.mValueMap = UstarHeader.defaultValues();\r\n        this.update(attributes);\r\n    }\r\n    static isUstarHeader(value) {\r\n        return !!(value && value instanceof UstarHeader);\r\n    }\r\n    /**\r\n     * @returns A new `UstarHeader` instance based on the given attributes (if they are a POJO).\r\n     * Note that if the given value is already a UstarHeader instance, this will return it as-is.\r\n     */\r\n    static fromAttributes(attributes) {\r\n        return UstarHeader.isUstarHeader(attributes) ? attributes : new UstarHeader(attributes);\r\n    }\r\n    /**\r\n     * Short-hand for constructing a new `UstarHeader` and immediately calling `toUint8Array()` on it\r\n     */\r\n    static serializeAttributes(attributes) {\r\n        return UstarHeader.fromAttributes(attributes).toUint8Array();\r\n    }\r\n    /**\r\n     * Parses out a UstarHeader instance from the given input buffer, at the given offset.\r\n     * The given offset must be a multiple of SECTOR_SIZE.\r\n     *\r\n     * If the sector at the given offset is not marked with a ustar indicator,\r\n     * this will return null.\r\n     */\r\n    static deserialize(input, offset = 0) {\r\n        if (!TarHeaderUtility.isUstarSector(input, offset)) {\r\n            return null;\r\n        }\r\n        const attributes = {};\r\n        for (const field of TarHeaderUtility.ALL_FIELDS) {\r\n            attributes[field.name] = field.readFrom(input, offset);\r\n        }\r\n        return new UstarHeader(attributes);\r\n    }\r\n    static defaultValues() {\r\n        return {\r\n            fileName: '',\r\n            fileMode: Constants.FILE_MODE_DEFAULT,\r\n            groupUserId: 0,\r\n            ownerUserId: 0,\r\n            fileSize: 0,\r\n            lastModified: TarUtility.getUstarTimestamp(),\r\n            headerChecksum: 0,\r\n            linkedFileName: '',\r\n            typeFlag: UstarHeaderLinkIndicatorType.NORMAL_FILE,\r\n            ustarIndicator: Constants.USTAR_INDICATOR_VALUE,\r\n            ustarVersion: Constants.USTAR_VERSION_VALUE,\r\n            ownerUserName: '',\r\n            ownerGroupName: '',\r\n            deviceMajorNumber: '00',\r\n            deviceMinorNumber: '00',\r\n            fileNamePrefix: '',\r\n        };\r\n    }\r\n    get fileName() {\r\n        return this.mValueMap.fileName;\r\n    }\r\n    set fileName(value) {\r\n        this.mValueMap.fileName = value;\r\n    }\r\n    get fileMode() {\r\n        return this.mValueMap.fileMode;\r\n    }\r\n    set fileMode(value) {\r\n        this.mValueMap.fileMode = value;\r\n    }\r\n    get ownerUserId() {\r\n        return this.mValueMap.ownerUserId;\r\n    }\r\n    set ownerUserId(value) {\r\n        this.mValueMap.ownerUserId = value;\r\n    }\r\n    get groupUserId() {\r\n        return this.mValueMap.groupUserId;\r\n    }\r\n    set groupUserId(value) {\r\n        this.mValueMap.groupUserId = value;\r\n    }\r\n    get fileSize() {\r\n        return this.mValueMap.fileSize;\r\n    }\r\n    set fileSize(value) {\r\n        this.mValueMap.fileSize = value;\r\n    }\r\n    get lastModified() {\r\n        return this.mValueMap.lastModified;\r\n    }\r\n    set lastModified(value) {\r\n        this.mValueMap.lastModified = TarUtility.sanitizeDateTimeAsUstar(value);\r\n    }\r\n    get headerChecksum() {\r\n        return this.mValueMap.headerChecksum;\r\n    }\r\n    set headerChecksum(value) {\r\n        this.mValueMap.headerChecksum = value;\r\n    }\r\n    get linkedFileName() {\r\n        return this.mValueMap.linkedFileName;\r\n    }\r\n    set linkedFileName(value) {\r\n        this.mValueMap.linkedFileName = value;\r\n    }\r\n    get typeFlag() {\r\n        return this.mValueMap.typeFlag;\r\n    }\r\n    set typeFlag(value) {\r\n        this.mValueMap.typeFlag = value;\r\n    }\r\n    get ustarIndicator() {\r\n        return this.mValueMap.ustarIndicator;\r\n    }\r\n    get ustarVersion() {\r\n        return this.mValueMap.ustarVersion;\r\n    }\r\n    set ustarVersion(value) {\r\n        this.mValueMap.ustarVersion = value;\r\n    }\r\n    get ownerUserName() {\r\n        return this.mValueMap.ownerUserName;\r\n    }\r\n    set ownerUserName(value) {\r\n        this.mValueMap.ownerUserName = value;\r\n    }\r\n    get ownerGroupName() {\r\n        return this.mValueMap.ownerGroupName;\r\n    }\r\n    set ownerGroupName(value) {\r\n        this.mValueMap.ownerGroupName = value;\r\n    }\r\n    get deviceMajorNumber() {\r\n        return this.mValueMap.deviceMajorNumber;\r\n    }\r\n    set deviceMajorNumber(value) {\r\n        this.mValueMap.deviceMajorNumber = value;\r\n    }\r\n    get deviceMinorNumber() {\r\n        return this.mValueMap.deviceMinorNumber;\r\n    }\r\n    set deviceMinorNumber(value) {\r\n        this.mValueMap.deviceMinorNumber = value;\r\n    }\r\n    get fileNamePrefix() {\r\n        return this.mValueMap.fileNamePrefix;\r\n    }\r\n    set fileNamePrefix(value) {\r\n        this.mValueMap.fileNamePrefix = value;\r\n    }\r\n    get isPaxHeader() {\r\n        return this.isLocalPaxHeader || this.isGlobalPaxHeader;\r\n    }\r\n    get isGlobalPaxHeader() {\r\n        return this.typeFlag === UstarHeaderLinkIndicatorType.GLOBAL_EXTENDED_HEADER;\r\n    }\r\n    get isLocalPaxHeader() {\r\n        return this.typeFlag === UstarHeaderLinkIndicatorType.LOCAL_EXTENDED_HEADER;\r\n    }\r\n    get isFileHeader() {\r\n        return TarHeaderUtility.isTarHeaderLinkIndicatorTypeFile(this.typeFlag);\r\n    }\r\n    get isDirectoryHeader() {\r\n        return TarHeaderUtility.isTarHeaderLinkIndicatorTypeDirectory(this.typeFlag);\r\n    }\r\n    update(attributes) {\r\n        Object.assign(this.mValueMap, attributes);\r\n        return this;\r\n    }\r\n    toAttributes() {\r\n        return Object.assign({}, this.mValueMap);\r\n    }\r\n    toUint8Array() {\r\n        const result = new Uint8Array(Constants.HEADER_SIZE);\r\n        let checksum = TarHeaderUtility.CHECKSUM_SEED;\r\n        for (const field of TarHeaderUtility.CHECKSUM_FIELDS) {\r\n            field.writeTo(result, 0, this.mValueMap[field.name]);\r\n            checksum += field.calculateChecksum(result);\r\n        }\r\n        this.headerChecksum = checksum;\r\n        UstarHeaderField.headerChecksum.writeTo(result, 0, checksum);\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const attributes = this.toAttributes();\r\n        const bytes = this.toUint8Array();\r\n        const buffer = TarUtility.getDebugBufferJson(bytes);\r\n        return {\r\n            attributes,\r\n            buffer,\r\n        };\r\n    }\r\n}\r\n", "import { TarUtility } from '../common/tar-utility';\r\nimport { PaxHeader } from './pax/pax-header';\r\nimport { UstarHeader } from './ustar/ustar-header';\r\nimport { UstarHeaderField } from './ustar/ustar-header-field';\r\nimport { UstarHeaderLinkIndicatorType } from './ustar/ustar-header-link-indicator-type';\r\n/**\r\n * Facade over a backing Uint8Array buffer to consume/edit header data\r\n * at a specific location in the buffer.\r\n *\r\n * Does not perform any mutations or reads on creation, and\r\n * lazy loads/sets data via getters and setters.\r\n */\r\nexport class TarHeader {\r\n    constructor(options) {\r\n        const { ustar, pax, preamble, isPaxGlobal } = options;\r\n        this.ustar = ustar;\r\n        this.pax = pax;\r\n        this.mPreamble = preamble;\r\n        this.mIsGlobal = !!isPaxGlobal;\r\n        this.trySyncPaxHeader();\r\n    }\r\n    static isTarHeader(value) {\r\n        return !!(value && value instanceof TarHeader);\r\n    }\r\n    /**\r\n     * @returns A new `TarHeader` instance based on the given attributes (if they are a POJO).\r\n     * Note that if the given value is already a TarHeader instance, this will return it as-is.\r\n     */\r\n    static fromAttributes(attributes) {\r\n        if (TarHeader.isTarHeader(attributes)) {\r\n            return attributes;\r\n        }\r\n        const ustar = new UstarHeader(attributes);\r\n        const paxRequiredAttributes = TarHeader.collectPaxRequiredAttributes(attributes);\r\n        let pax;\r\n        if (paxRequiredAttributes) {\r\n            // The path property is the only reason we fall back to PAX as of now.\r\n            // This block may need to be wrapped in a check for the path property if other attributes are added later on.\r\n            const [directoryName, fileName] = TarHeader.splitBaseFileName(paxRequiredAttributes.path);\r\n            ustar.fileName = fileName;\r\n            ustar.fileNamePrefix = directoryName;\r\n            pax = PaxHeader.fromAttributes(paxRequiredAttributes);\r\n        }\r\n        return new TarHeader({ ustar, pax });\r\n    }\r\n    /**\r\n     * Short-hand for constructing a new `TarHeader` and immediately calling `toUint8Array()` on it\r\n     */\r\n    static serializeAttributes(attributes) {\r\n        if (TarHeader.isTarHeader(attributes)) {\r\n            return attributes.toUint8Array();\r\n        }\r\n        return TarHeader.fromAttributes(attributes).toUint8Array();\r\n    }\r\n    static collectPaxRequiredAttributes(attributes) {\r\n        if (TarUtility.isObject(attributes)) {\r\n            let collected = {};\r\n            if (attributes.fileName && attributes.fileName.length > UstarHeaderField.fileName.size) {\r\n                collected.path = attributes.fileName;\r\n            }\r\n            if (Object.keys(collected).length > 0) {\r\n                return collected;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    static splitBaseFileName(fileName) {\r\n        let offset = fileName.lastIndexOf('/');\r\n        if (offset >= 0) {\r\n            return [fileName.substring(0, offset), fileName.substring(offset + 1)];\r\n        }\r\n        offset = fileName.lastIndexOf('\\\\');\r\n        if (offset >= 0) {\r\n            return [fileName.substring(0, offset), fileName.substring(offset + 1)];\r\n        }\r\n        return ['', fileName];\r\n    }\r\n    get preamble() {\r\n        return this.mPreamble;\r\n    }\r\n    get fileName() {\r\n        return this.pax?.path || this.ustar.fileName;\r\n    }\r\n    get fileMode() {\r\n        return this.ustar.fileMode;\r\n    }\r\n    get ownerUserId() {\r\n        return this.pax?.userId || this.ustar.ownerUserId;\r\n    }\r\n    get groupUserId() {\r\n        return this.pax?.groupId || this.ustar.groupUserId;\r\n    }\r\n    get fileSize() {\r\n        return this.pax?.size || this.ustar.fileSize;\r\n    }\r\n    get lastModified() {\r\n        return this.pax?.lastModified || this.ustar.lastModified;\r\n    }\r\n    get headerChecksum() {\r\n        return this.ustar.headerChecksum;\r\n    }\r\n    get linkedFileName() {\r\n        return this.pax?.linkPath || this.ustar.linkedFileName;\r\n    }\r\n    get typeFlag() {\r\n        return this.ustar.typeFlag;\r\n    }\r\n    get ustarIndicator() {\r\n        return this.ustar.ustarIndicator;\r\n    }\r\n    get ustarVersion() {\r\n        return this.ustar.ustarVersion;\r\n    }\r\n    get ownerUserName() {\r\n        return this.pax?.userName || this.ustar.ownerUserName;\r\n    }\r\n    get ownerGroupName() {\r\n        return this.pax?.groupName || this.ustar.ownerGroupName;\r\n    }\r\n    get deviceMajorNumber() {\r\n        return this.ustar.deviceMajorNumber;\r\n    }\r\n    get deviceMinorNumber() {\r\n        return this.ustar.deviceMinorNumber;\r\n    }\r\n    get fileNamePrefix() {\r\n        return this.ustar.fileNamePrefix;\r\n    }\r\n    get isPaxHeader() {\r\n        return this.isLocalPaxHeader || this.isGlobalPaxHeader;\r\n    }\r\n    get isGlobalPaxHeader() {\r\n        return this.isGlobalPaxPreHeader || this.isGlobalPaxPostHeader;\r\n    }\r\n    get isLocalPaxHeader() {\r\n        return this.isLocalPaxPreHeader || this.isLocalPaxPostHeader;\r\n    }\r\n    get isGlobalPaxPreHeader() {\r\n        return this.ustar.isGlobalPaxHeader;\r\n    }\r\n    get isLocalPaxPreHeader() {\r\n        return this.ustar.isLocalPaxHeader;\r\n    }\r\n    get isGlobalPaxPostHeader() {\r\n        return this.preamble?.isGlobalPaxHeader ?? false;\r\n    }\r\n    get isLocalPaxPostHeader() {\r\n        return this.preamble?.isLocalPaxHeader ?? false;\r\n    }\r\n    get isFileHeader() {\r\n        return this.ustar.isFileHeader;\r\n    }\r\n    get isDirectoryHeader() {\r\n        return this.ustar.isDirectoryHeader;\r\n    }\r\n    /**\r\n     * Removes any unknown or un-standardized keys from\r\n     * the PAX portion of this header (if one exists).\r\n     *\r\n     * See also `PaxHeader.clean()`.\r\n     *\r\n     * @returns `this` for operation chaining\r\n     */\r\n    clean() {\r\n        this.pax?.clean();\r\n        return this;\r\n    }\r\n    /**\r\n     * Ensures that things such as checksum values are\r\n     * synchronized with the current underlying header states.\r\n     *\r\n     * @returns `this` for operation chaining\r\n     */\r\n    normalize() {\r\n        this.trySyncPaxHeader();\r\n        return this;\r\n    }\r\n    /**\r\n     * @returns A snapshot of the underlying buffer for this header\r\n     */\r\n    toUint8Array() {\r\n        this.normalize();\r\n        const isPax = !!(this.isPaxHeader && this.pax && this.preamble);\r\n        if (!isPax) {\r\n            return this.ustar.toUint8Array();\r\n        }\r\n        const preambleBytes = this.preamble.toUint8Array();\r\n        const paxBytes = this.pax.toUint8ArrayPadded();\r\n        const ownBytes = this.ustar.toUint8Array();\r\n        const totalSize = preambleBytes.byteLength + paxBytes.byteLength + ownBytes.byteLength;\r\n        const result = new Uint8Array(totalSize);\r\n        let offset = 0;\r\n        result.set(preambleBytes, offset);\r\n        offset += preambleBytes.byteLength;\r\n        result.set(paxBytes, offset);\r\n        offset += paxBytes.byteLength;\r\n        result.set(ownBytes, offset);\r\n        return result;\r\n    }\r\n    toJSON() {\r\n        const { pax, preamble, ustar } = this;\r\n        return { preamble, pax, ustar };\r\n    }\r\n    trySyncPaxHeader() {\r\n        if (!this.pax) {\r\n            return;\r\n        }\r\n        const fileName = this.fileName;\r\n        const fileSize = this.pax.toUint8Array().byteLength;\r\n        const lastModified = this.pax.lastModified;\r\n        const typeFlag = this.mIsGlobal\r\n            ? UstarHeaderLinkIndicatorType.GLOBAL_EXTENDED_HEADER\r\n            : UstarHeaderLinkIndicatorType.LOCAL_EXTENDED_HEADER;\r\n        const preambleAttrs = {\r\n            fileName,\r\n            typeFlag,\r\n            lastModified,\r\n            fileSize,\r\n        };\r\n        if (this.mPreamble) {\r\n            this.mPreamble.update(preambleAttrs);\r\n        }\r\n        else {\r\n            this.mPreamble = new UstarHeader(preambleAttrs);\r\n        }\r\n    }\r\n}\r\n", "import { TarUtility } from '../common/tar-utility';\r\nimport { TarHeader } from '../header/tar-header';\r\n/**\r\n * Container for metadata and content of a tarball entry.\r\n *\r\n * Here, we consider an \"entry\" to be a tuple of:\r\n * 1. The parsed USTAR header sector content (AKA TarHeader)\r\n * 2. The aggregate of the proceeding file content sectors, based on the header's file size attribute\r\n */\r\nexport class ArchiveEntry {\r\n    constructor(options = {}) {\r\n        let { header, headerAttributes, headerByteLength, content, offset, context } = options;\r\n        if (!header)\r\n            header = TarHeader.fromAttributes(headerAttributes || {});\r\n        if (!content)\r\n            content = null;\r\n        if (!offset)\r\n            offset = 0;\r\n        if (!context)\r\n            context = null;\r\n        const contentLength = TarUtility.sizeofUint8Array(content);\r\n        // The fileSize field metadata must always be in sync between the content and the header\r\n        if (!header.pax && header.fileSize !== contentLength && contentLength > 0) {\r\n            header.ustar.fileSize = contentLength;\r\n        }\r\n        // run this last since toUint8Array() also syncs checksums\r\n        if (!headerByteLength)\r\n            headerByteLength = header.toUint8Array().byteLength;\r\n        this.mHeader = header;\r\n        this.mHeaderByteLength = headerByteLength;\r\n        this.mContent = content;\r\n        this.mOffset = offset;\r\n        this.mContext = context;\r\n    }\r\n    static isArchiveEntry(v) {\r\n        return !!(v && v instanceof ArchiveEntry);\r\n    }\r\n    // =================================================================\r\n    // TarHeader Interface Fields\r\n    // =================================================================\r\n    get fileName() {\r\n        return this.header.fileName;\r\n    }\r\n    get fileSize() {\r\n        return this.header.fileSize;\r\n    }\r\n    get fileMode() {\r\n        return this.header.fileMode;\r\n    }\r\n    get ownerUserId() {\r\n        return this.header.ownerUserId;\r\n    }\r\n    get groupUserId() {\r\n        return this.header.groupUserId;\r\n    }\r\n    get lastModified() {\r\n        return this.header.lastModified;\r\n    }\r\n    get headerChecksum() {\r\n        return this.header.headerChecksum;\r\n    }\r\n    get linkedFileName() {\r\n        return this.header.linkedFileName;\r\n    }\r\n    get typeFlag() {\r\n        return this.header.typeFlag;\r\n    }\r\n    get ustarIndicator() {\r\n        return this.header.ustarIndicator;\r\n    }\r\n    get ustarVersion() {\r\n        return this.header.ustarVersion;\r\n    }\r\n    get ownerUserName() {\r\n        return this.header.ownerUserName;\r\n    }\r\n    get ownerGroupName() {\r\n        return this.header.ownerGroupName;\r\n    }\r\n    get deviceMajorNumber() {\r\n        return this.header.deviceMajorNumber;\r\n    }\r\n    get deviceMinorNumber() {\r\n        return this.header.deviceMinorNumber;\r\n    }\r\n    get fileNamePrefix() {\r\n        return this.header.fileNamePrefix;\r\n    }\r\n    // =================================================================\r\n    // Introspection Fields\r\n    // =================================================================\r\n    /**\r\n     * The header metadata parsed out for this entry.\r\n     * If you are attempting to read the content of this entry,\r\n     * do not modify this instance.\r\n     */\r\n    get header() {\r\n        return this.mHeader;\r\n    }\r\n    /**\r\n     * The file content for this entry.\r\n     * This may be null for entries loaded asynchronously, or\r\n     * for non-file entries like directories.\r\n     */\r\n    get content() {\r\n        return this.mContent;\r\n    }\r\n    /**\r\n     * The starting absolute index (inclusive) in the source buffer that this entry was parsed from.\r\n     * Returns zero by default if this was not parsed by a source buffer.\r\n     */\r\n    get sourceOffset() {\r\n        return this.mOffset;\r\n    }\r\n    /**\r\n     * The size in bytes of the header in the source buffer that this entry was parsed from.\r\n     * Returns zero by default if this was not parsed by a source buffer.\r\n     */\r\n    get sourceHeaderByteLength() {\r\n        return this.mHeaderByteLength;\r\n    }\r\n    /**\r\n     * The context (if any) from which this entry was parsed.\r\n     * The context will include global data about things such as\r\n     * the origin of the archive and global pax headers.\r\n     */\r\n    get sourceContext() {\r\n        return this.mContext;\r\n    }\r\n    isDirectory() {\r\n        return this.header.isDirectoryHeader;\r\n    }\r\n    isFile() {\r\n        return this.header.isFileHeader;\r\n    }\r\n    /**\r\n     * Convenience for decoding the current content buffer as a string.\r\n     * Note that if the content was not loaded for whatever reason, this\r\n     * will return an empty string.\r\n     * @returns The decoded string data from the currently assigned content,\r\n     * or an empty string if there is no content assigned.\r\n     */\r\n    text() {\r\n        return TarUtility.decodeString(this.content);\r\n    }\r\n    /**\r\n     * Only necessary if this entry was extracted from an async buffer, since the entry\r\n     * does not hold the content of async buffers by default.\r\n     *\r\n     * If the entry was extracted synchronously, its content will be available via the \"content\" property.\r\n     *\r\n     * Do not use this on entries that have not been parsed from a source buffer,\r\n     * otherwise it will very likely return garbage data.\r\n     *\r\n     * @param buffer - the source to read content from\r\n     * @param offset - the _relative_ offset of the content to read;\r\n     * \t\t\t\t\tsetting this to 42 will start reading at the 42nd byte index within the content block\r\n     * @param length - the number of bytes to read after the offset\r\n     */\r\n    async readContentFrom(buffer, offset = 0, length = 0) {\r\n        const fileSize = this.fileSize;\r\n        const contentStartIndex = this.sourceOffset + this.sourceHeaderByteLength;\r\n        const contentEndIndex = contentStartIndex + fileSize;\r\n        const absoluteOffset = contentStartIndex + TarUtility.clamp(offset, 0, fileSize);\r\n        const bytesRemaining = Math.max(0, contentEndIndex - absoluteOffset);\r\n        const normalizedLength = length > 0 ? Math.min(length, bytesRemaining) : bytesRemaining;\r\n        return buffer.read(absoluteOffset, normalizedLength);\r\n    }\r\n    /**\r\n     * @returns This instance serialized as a single slice for a tar buffer\r\n     */\r\n    toUint8Array() {\r\n        const headerBytes = this.header.toUint8Array();\r\n        const contentLength = this.content?.byteLength ?? 0;\r\n        const outputLength = TarUtility.roundUpSectorOffset(headerBytes.byteLength + contentLength);\r\n        const result = new Uint8Array(outputLength);\r\n        result.set(headerBytes, 0);\r\n        if (contentLength > 0) {\r\n            result.set(this.content, headerBytes.byteLength);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Overridden to prevent circular reference errors / huge memory spikes that would\r\n     * include the underlying content by default.\r\n     */\r\n    toJSON() {\r\n        const { header, fileName: name, fileSize: size, content } = this;\r\n        const isFile = this.isFile();\r\n        const isDirectory = this.isDirectory();\r\n        const type = isFile ? 'file' : isDirectory ? 'directory' : 'complex';\r\n        const contentType = content ? 'Uint8Array[' + content.byteLength + ']' : 'null';\r\n        return {\r\n            name,\r\n            size,\r\n            type,\r\n            header,\r\n            contentType,\r\n            content: TarUtility.getDebugHexString(content),\r\n        };\r\n    }\r\n}\r\n", "import { InMemoryAsyncUint8Array } from '../common/async-uint8-array';\r\nimport { AsyncUint8ArrayIterator } from '../common/async-uint8-array-iterator';\r\nimport { Constants } from '../common/constants';\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { PaxHeader } from '../header/pax/pax-header';\r\nimport { TarHeader } from '../header/tar-header';\r\nimport { TarHeaderUtility } from '../header/tar-header-utility';\r\nimport { UstarHeader } from '../header/ustar/ustar-header';\r\nimport { ArchiveEntry } from './archive-entry';\r\nconst MAX_LOADED_BYTES = Constants.SECTOR_SIZE * 100000; // ~50Mb\r\n/**\r\n * Errors that will be thrown if the reader encounters an invalid data layout\r\n */\r\nexport var ArchiveReadError;\r\n(function (ArchiveReadError) {\r\n    /**\r\n     * Occurs when the reader fails to fully load the content buffer of an entry\r\n     * due to the input data stream ending prematurely.\r\n     */\r\n    ArchiveReadError[\"ERR_ENTRY_CONTENT_MIN_BUFFER_LENGTH_NOT_MET\"] = \"ERR_ENTRY_CONTENT_MIN_BUFFER_LENGTH_NOT_MET\";\r\n    /**\r\n     * Occurs when the reader fails to fully load a PAX header\r\n     * due to the input data stream ending prematurely.\r\n     */\r\n    ArchiveReadError[\"ERR_HEADER_PAX_MIN_BUFFER_LENGTH_NOT_MET\"] = \"ERR_HEADER_PAX_MIN_BUFFER_LENGTH_NOT_MET\";\r\n    /**\r\n     * Occurs when the reader fails to fully load a PAX header\r\n     * due to the third and final segment not appearing in the input data stream.\r\n     */\r\n    ArchiveReadError[\"ERR_HEADER_MISSING_POST_PAX_SEGMENT\"] = \"ERR_HEADER_MISSING_POST_PAX_SEGMENT\";\r\n})(ArchiveReadError || (ArchiveReadError = {}));\r\n/**\r\n * Generic utility for parsing tar entries from a stream of octets via `AsyncUint8ArrayIterator`\r\n */\r\nexport class ArchiveReader {\r\n    constructor(bufferIterator) {\r\n        this.bufferIterator = bufferIterator;\r\n        this.mGlobalPaxHeaders = [];\r\n        this.mBufferCache = null;\r\n        this.mOffset = 0;\r\n        this.mHasSyncInput = this.bufferIterator.input instanceof InMemoryAsyncUint8Array;\r\n    }\r\n    static withInput(input) {\r\n        return new ArchiveReader(new AsyncUint8ArrayIterator(input));\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return this;\r\n    }\r\n    get source() {\r\n        return this.bufferIterator.input;\r\n    }\r\n    get globalPaxHeaders() {\r\n        return this.mGlobalPaxHeaders;\r\n    }\r\n    async readAllEntries() {\r\n        const entries = [];\r\n        for await (const entry of this) {\r\n            entries.push(entry);\r\n        }\r\n        return entries;\r\n    }\r\n    async next() {\r\n        const entry = await this.tryParseNextEntry();\r\n        if (entry !== null) {\r\n            return { done: false, value: entry };\r\n        }\r\n        return { done: true, value: null };\r\n    }\r\n    clearBufferCache() {\r\n        this.mBufferCache = null;\r\n        this.mOffset = 0;\r\n    }\r\n    getBufferCacheSlice(start, end) {\r\n        return TarUtility.cloneUint8Array(this.mBufferCache, start, end);\r\n    }\r\n    async tryRequireBufferSize(size) {\r\n        const buffer = await this.requireBufferSize(size);\r\n        return buffer !== null;\r\n    }\r\n    async requireBufferSize(size) {\r\n        while (!this.mBufferCache || this.mBufferCache.byteLength < size) {\r\n            if (!(await this.loadNextChunk())) {\r\n                this.clearBufferCache();\r\n                return null;\r\n            }\r\n        }\r\n        return this.mBufferCache;\r\n    }\r\n    async loadNextChunk() {\r\n        const nextChunk = await this.bufferIterator.tryNext();\r\n        if (!nextChunk) {\r\n            return false;\r\n        }\r\n        if (this.mBufferCache) {\r\n            this.mBufferCache = TarUtility.concatUint8Arrays(this.mBufferCache, nextChunk);\r\n        }\r\n        else {\r\n            this.mBufferCache = nextChunk;\r\n            this.mOffset = 0;\r\n        }\r\n        return true;\r\n    }\r\n    async tryParseNextEntry() {\r\n        const headerParseResult = await this.tryParseNextHeader();\r\n        if (headerParseResult === null) {\r\n            this.clearBufferCache();\r\n            return null;\r\n        }\r\n        const context = this;\r\n        const { header, headerOffset, contentOffset } = headerParseResult;\r\n        const headerByteLength = contentOffset - headerOffset;\r\n        const contentEnd = contentOffset + header.fileSize;\r\n        const offset = headerOffset;\r\n        // `contentEnd` may not be an even division of SECTOR_SIZE, so\r\n        // round up to the nearest sector start point after the content end.\r\n        const nextSectorStart = TarUtility.roundUpSectorOffset(contentEnd);\r\n        let content = null;\r\n        // If the buffer source is in-memory already, just read the content immediately\r\n        if (this.mHasSyncInput && header.fileSize > 0) {\r\n            if (!(await this.tryRequireBufferSize(nextSectorStart))) {\r\n                throw ArchiveReadError.ERR_ENTRY_CONTENT_MIN_BUFFER_LENGTH_NOT_MET;\r\n            }\r\n            content = this.getBufferCacheSlice(contentOffset, contentEnd);\r\n        }\r\n        // if some of the in-memory buffer is left over after this iteration,\r\n        // trim this entry's bytes off of the buffer and reset the offset pointer.\r\n        if (nextSectorStart + Constants.SECTOR_SIZE <= this.mBufferCache.byteLength) {\r\n            this.mBufferCache = this.getBufferCacheSlice(nextSectorStart);\r\n            this.mOffset = 0;\r\n            // otherwise, move the offset pointer so more data will be loaded in the next iterator call\r\n        }\r\n        else {\r\n            this.mOffset = nextSectorStart;\r\n        }\r\n        return new ArchiveEntry({ header, offset, headerByteLength, content, context });\r\n    }\r\n    async tryParseNextHeader() {\r\n        if (!(await this.tryRequireBufferSize(this.mOffset + Constants.HEADER_SIZE))) {\r\n            return null;\r\n        }\r\n        let ustarOffset = TarHeaderUtility.findNextUstarSectorOffset(this.mBufferCache, this.mOffset);\r\n        // Find next ustar marker\r\n        while (ustarOffset < 0 && this.mBufferCache.byteLength < MAX_LOADED_BYTES && (await this.loadNextChunk())) {\r\n            ustarOffset = TarHeaderUtility.findNextUstarSectorOffset(this.mBufferCache, this.mOffset);\r\n        }\r\n        // No header marker found and we ran out of bytes to load, terminate\r\n        if (ustarOffset < 0) {\r\n            this.clearBufferCache();\r\n            return null;\r\n        }\r\n        // Construct Header\r\n        let headerOffset = ustarOffset;\r\n        let headerBuffer = this.getBufferCacheSlice(headerOffset, headerOffset + Constants.HEADER_SIZE);\r\n        let ustarHeader = UstarHeader.deserialize(headerBuffer);\r\n        let header = new TarHeader({ ustar: ustarHeader });\r\n        // Advance cursor to process potential PAX header or entry content\r\n        let nextOffset = TarUtility.advanceSectorOffset(headerOffset, this.mBufferCache.byteLength);\r\n        if (ustarHeader.isPaxHeader) {\r\n            // Make sure we've buffered the pax header region and the next sector after that (next sector contains the _actual_ header)\r\n            const paxHeaderSectorEnd = nextOffset + TarUtility.roundUpSectorOffset(header.fileSize);\r\n            const requiredBufferSize = paxHeaderSectorEnd + Constants.HEADER_SIZE;\r\n            const isGlobalPax = header.isGlobalPaxHeader;\r\n            const preambleHeader = ustarHeader;\r\n            if (!(await this.tryRequireBufferSize(requiredBufferSize))) {\r\n                throw ArchiveReadError.ERR_HEADER_PAX_MIN_BUFFER_LENGTH_NOT_MET;\r\n            }\r\n            // Parse the pax header out from the next sector\r\n            const paxHeader = PaxHeader.deserialize(this.mBufferCache, nextOffset);\r\n            nextOffset = paxHeaderSectorEnd;\r\n            if (!TarHeaderUtility.isUstarSector(this.mBufferCache, nextOffset)) {\r\n                throw ArchiveReadError.ERR_HEADER_MISSING_POST_PAX_SEGMENT;\r\n            }\r\n            // The _actual_ header is AFTER the pax header, so need to do the header parse song and dance one more time\r\n            headerOffset = nextOffset;\r\n            headerBuffer = this.getBufferCacheSlice(headerOffset, headerOffset + Constants.HEADER_SIZE);\r\n            ustarHeader = UstarHeader.deserialize(headerBuffer);\r\n            nextOffset = TarUtility.advanceSectorOffsetUnclamped(nextOffset);\r\n            header = new TarHeader({\r\n                ustar: ustarHeader,\r\n                pax: paxHeader,\r\n                preamble: preambleHeader,\r\n            });\r\n            if (isGlobalPax) {\r\n                this.mGlobalPaxHeaders.push(header);\r\n            }\r\n        }\r\n        return { header, headerOffset, contentOffset: nextOffset };\r\n    }\r\n}\r\n", "import { Constants } from '../common/constants';\r\nimport { TarUtility } from '../common/tar-utility';\r\nimport { UstarHeaderLinkIndicatorType } from '../header/ustar/ustar-header-link-indicator-type';\r\nimport { ArchiveEntry } from './archive-entry';\r\n/**\r\n * Generic utility for building a tar octet stream by adding JSON-style entries.\r\n * See the `add***()` options in this class definition for details.\r\n */\r\nexport class ArchiveWriter {\r\n    constructor(entries = []) {\r\n        this.entries = entries;\r\n    }\r\n    /**\r\n     * Combines the given array of entries into a single, complete tarball buffer\r\n     */\r\n    static serialize(entries) {\r\n        let outputLength = Constants.TERMINAL_PADDING_SIZE;\r\n        const outputBuffers = [];\r\n        for (const entry of entries) {\r\n            const entryBytes = entry.toUint8Array();\r\n            outputBuffers.push(entryBytes);\r\n            outputLength += entryBytes.byteLength;\r\n        }\r\n        const output = new Uint8Array(outputLength);\r\n        let offset = 0;\r\n        for (const entryBuf of outputBuffers) {\r\n            output.set(entryBuf, offset);\r\n            offset += entryBuf.byteLength;\r\n        }\r\n        return output;\r\n    }\r\n    /**\r\n     * @returns a complete tar buffer from all the currently set tar entries in this instance.\r\n     */\r\n    toUint8Array() {\r\n        return ArchiveWriter.serialize(this.entries);\r\n    }\r\n    /**\r\n     * Convenience for appending a new entry to the existing `entries` array\r\n     * @returns `this` for operation chaining\r\n     */\r\n    addEntry(entry) {\r\n        this.entries.push(entry);\r\n        return this;\r\n    }\r\n    /**\r\n     * Convenience for appending a new entry to the existing `entries` array.\r\n     * @returns `this` for operation chaining\r\n     */\r\n    addEntryWith(header, content) {\r\n        return this.addEntry(new ArchiveEntry({ headerAttributes: header, content }));\r\n    }\r\n    /**\r\n     * Convenience option for building tarball data\r\n     * @param path - the file name, e.g. './relative/path/to/your/file.txt'\r\n     * @param content - the content of the file (shocker!)\r\n     * @param headerOptions - custom options for this entry\r\n     * @returns `this` for operation chaining\r\n     */\r\n    addTextFile(path, content, headerOptions) {\r\n        return this.addBinaryFile(path, TarUtility.encodeString(content), headerOptions);\r\n    }\r\n    /**\r\n     * Convenience option for building tarball data\r\n     * @param path - the file name, e.g. './relative/path/to/your/file.bin'\r\n     * @param content - the content of the file (shocker!)\r\n     * @param headerOptions - custom options for this entry\r\n     * @returns `this` for operation chaining\r\n     */\r\n    addBinaryFile(path, content, headerOptions = {}) {\r\n        const combinedHeaderOptions = Object.assign({\r\n            fileName: path,\r\n            fileSize: content.byteLength,\r\n            typeFlag: UstarHeaderLinkIndicatorType.NORMAL_FILE,\r\n        }, headerOptions);\r\n        return this.addEntryWith(combinedHeaderOptions, content);\r\n    }\r\n    /**\r\n     * Convenience option for building tarball data\r\n     * @param path - the directory name, e.g. './relative/path/to/your/dir'\r\n     * @param headerOptions - custom options for this entry\r\n     * @returns `this` for operation chaining\r\n     */\r\n    addDirectory(path, headerOptions = {}) {\r\n        const combinedHeaderOptions = Object.assign({\r\n            fileName: path,\r\n            typeFlag: UstarHeaderLinkIndicatorType.DIRECTORY,\r\n        }, headerOptions);\r\n        return this.addEntryWith(combinedHeaderOptions);\r\n    }\r\n    /**\r\n     * Removes any entries from this writer's cache that meet the given predicate condition.\r\n     * @param predicate - delegate that will return true for any entry that should be removed.\r\n     * @returns `this` for operation chaining\r\n     */\r\n    removeEntriesWhere(predicate) {\r\n        this.entries = this.entries.filter((v) => !predicate(v));\r\n        return this;\r\n    }\r\n    /**\r\n     * Convenience option for cleaning the header of each listed entry.\r\n     * When headers are \"cleaned\", unknown PAX properties will be removed\r\n     * (e.g. unwanted MacOS \"quarantine\" headers), and USTAR fields\r\n     * will be normalized (if necessary).\r\n     */\r\n    cleanAllHeaders() {\r\n        for (const entry of this.entries) {\r\n            entry.header.clean();\r\n        }\r\n        return this;\r\n    }\r\n}\r\n", "import { ArchiveReader } from './archive-reader';\r\nimport { ArchiveWriter } from './archive-writer';\r\n/**\r\n * Main entry point for extracting and creating tarballs.\r\n * See TarIterator and ArchiveEntry for more granular options.\r\n */\r\nexport class Archive extends ArchiveWriter {\r\n    constructor(entries) {\r\n        super(entries);\r\n    }\r\n    /**\r\n     * Parses an Archive instance from the given buffer, with all entries read into memory.\r\n     * The buffer should come from a complete, uncompressed tar file.\r\n     */\r\n    static async extract(input) {\r\n        const reader = ArchiveReader.withInput(input);\r\n        const entries = await reader.readAllEntries();\r\n        return new Archive(entries);\r\n    }\r\n    /**\r\n     * Iterate over entries in-place from a given source buffer.\r\n     * The buffer should come from a complete, uncompressed tar file.\r\n     */\r\n    static read(input) {\r\n        return ArchiveReader.withInput(input);\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["Constants", "TarUtility", "UstarHeaderFieldType", "UstarHeaderFieldTransformType", "PaxHeaderKey", "PaxHeaderUtility", "UstarHeaderLinkIndicatorType", "TarHeaderUtility", "ArchiveReadError"]
}
