import "./chunk-WNKWOKNR.js";

// node_modules/@obsidize/tar-browserify/common/async-uint8-array.js
var InMemoryAsyncUint8Array = class {
  constructor(input) {
    this.input = input;
  }
  get byteLength() {
    return this.input.byteLength;
  }
  read(offset, length) {
    const max = this.input.byteLength;
    const start = Math.min(offset, max);
    const end = Math.min(start + length, max);
    return Promise.resolve(this.input.slice(start, end));
  }
};

// node_modules/@obsidize/tar-browserify/common/constants.js
var Constants;
(function(Constants2) {
  Constants2.SECTOR_SIZE = 512;
  Constants2.OCTAL_RADIX = 8;
  Constants2.USTAR_TAG = "ustar";
  Constants2.USTAR_INDICATOR_VALUE = `${Constants2.USTAR_TAG}\0`;
  Constants2.USTAR_VERSION_VALUE = "00";
  Constants2.HEADER_SIZE = Constants2.SECTOR_SIZE;
  Constants2.FILE_MODE_DEFAULT = 511;
  Constants2.TERMINAL_PADDING_SIZE = Constants2.SECTOR_SIZE * 2;
  Constants2.PAX_HEADER_PREFIX = "PaxHeader";
})(Constants || (Constants = {}));

// node_modules/@obsidize/tar-browserify/common/tar-utility.js
var TarUtility;
(function(TarUtility2) {
  function isNumber(value) {
    return typeof value === "number" && !Number.isNaN(value);
  }
  TarUtility2.isNumber = isNumber;
  function isString(value) {
    return typeof value === "string";
  }
  TarUtility2.isString = isString;
  function isUndefined(value) {
    return typeof value === "undefined";
  }
  TarUtility2.isUndefined = isUndefined;
  function isObject(value) {
    return typeof value === "object" && value !== null;
  }
  TarUtility2.isObject = isObject;
  function isDefined(value) {
    return !isUndefined(value);
  }
  TarUtility2.isDefined = isDefined;
  function isPopulatedString(value) {
    return isString(value) && value.length > 0;
  }
  TarUtility2.isPopulatedString = isPopulatedString;
  function isUint8Array(value) {
    return !!(value && value instanceof Uint8Array);
  }
  TarUtility2.isUint8Array = isUint8Array;
  function sizeofUint8Array(value) {
    return isUint8Array(value) ? value.byteLength : 0;
  }
  TarUtility2.sizeofUint8Array = sizeofUint8Array;
  function encodeString(input) {
    return isPopulatedString(input) ? new TextEncoder().encode(input) : new Uint8Array(0);
  }
  TarUtility2.encodeString = encodeString;
  function decodeString(input) {
    return isUint8Array(input) ? new TextDecoder().decode(input) : "";
  }
  TarUtility2.decodeString = decodeString;
  function generateChecksum(input) {
    return isUint8Array(input) ? input.reduce((a, b) => a + b, 0) : 0;
  }
  TarUtility2.generateChecksum = generateChecksum;
  function clamp(value, min, max) {
    return Math.max(min, Math.min(value, max));
  }
  TarUtility2.clamp = clamp;
  function advanceSectorOffset(currentOffset, maxOffset) {
    return Math.min(maxOffset, advanceSectorOffsetUnclamped(currentOffset));
  }
  TarUtility2.advanceSectorOffset = advanceSectorOffset;
  function advanceSectorOffsetUnclamped(currentOffset) {
    return (1 + Math.floor(currentOffset / Constants.SECTOR_SIZE)) * Constants.SECTOR_SIZE;
  }
  TarUtility2.advanceSectorOffsetUnclamped = advanceSectorOffsetUnclamped;
  function roundUpSectorOffset(currentOffset) {
    return Math.ceil(currentOffset / Constants.SECTOR_SIZE) * Constants.SECTOR_SIZE;
  }
  TarUtility2.roundUpSectorOffset = roundUpSectorOffset;
  function getSectorOffsetDelta(currentOffset) {
    return roundUpSectorOffset(currentOffset) - currentOffset;
  }
  TarUtility2.getSectorOffsetDelta = getSectorOffsetDelta;
  function parseIntOctal(input) {
    return parseIntSafe(input, Constants.OCTAL_RADIX);
  }
  TarUtility2.parseIntOctal = parseIntOctal;
  function dateTimeToUstar(dateTime) {
    return Math.floor(parseIntSafe(dateTime) / 1e3);
  }
  TarUtility2.dateTimeToUstar = dateTimeToUstar;
  function ustarTimeToDate(ustarTime) {
    return Math.floor(parseIntSafe(ustarTime)) * 1e3;
  }
  TarUtility2.ustarTimeToDate = ustarTimeToDate;
  function sanitizeDateTimeAsUstar(dateTime) {
    return ustarTimeToDate(dateTimeToUstar(dateTime));
  }
  TarUtility2.sanitizeDateTimeAsUstar = sanitizeDateTimeAsUstar;
  function getUstarTimestamp() {
    return sanitizeDateTimeAsUstar(Date.now());
  }
  TarUtility2.getUstarTimestamp = getUstarTimestamp;
  function paxTimeToDate(paxTime) {
    return Math.floor(paxTime * 1e3);
  }
  TarUtility2.paxTimeToDate = paxTimeToDate;
  function paxTimeToUstar(paxTime) {
    return Math.floor(paxTime);
  }
  TarUtility2.paxTimeToUstar = paxTimeToUstar;
  function getDebugHexString(v) {
    if (!isUint8Array(v))
      return "";
    return Array.from(v).map((b) => b.toString(16).padStart(2, "0").toUpperCase()).join(" ");
  }
  TarUtility2.getDebugHexString = getDebugHexString;
  function getDebugBufferJson(v) {
    return {
      byteLength: (v == null ? void 0 : v.byteLength) ?? 0,
      content: TarUtility2.getDebugHexString(v)
    };
  }
  TarUtility2.getDebugBufferJson = getDebugBufferJson;
  function removeTrailingZeros(str) {
    const pattern = /^([^\0]*)[\0]*$/;
    const result = pattern.exec(str);
    return result ? result[1] : str;
  }
  TarUtility2.removeTrailingZeros = removeTrailingZeros;
  function parseIntSafe(value, radix = 10, defaultValue = 0) {
    if (isNumber(value))
      return Math.floor(value);
    const parsed = parseInt(value, radix);
    return isNumber(parsed) ? parsed : defaultValue;
  }
  TarUtility2.parseIntSafe = parseIntSafe;
  function parseFloatSafe(value, defaultValue = 0) {
    if (isNumber(value))
      return value;
    const parsed = parseFloat(value);
    return isNumber(parsed) ? parsed : defaultValue;
  }
  TarUtility2.parseFloatSafe = parseFloatSafe;
  function cloneUint8Array(source, start, end) {
    if (!isUint8Array(source))
      return new Uint8Array(0);
    const sliced = source.slice(start, end);
    const bytes = Array.from(sliced);
    return Uint8Array.from(bytes);
  }
  TarUtility2.cloneUint8Array = cloneUint8Array;
  function concatUint8Arrays(a, b) {
    if (!isUint8Array(b))
      return a;
    if (!isUint8Array(a))
      return b;
    const aLength = a.byteLength;
    const bLength = b.byteLength;
    const result = new Uint8Array(aLength + bLength);
    if (aLength > 0)
      result.set(a, 0);
    if (bLength > 0)
      result.set(b, aLength);
    return result;
  }
  TarUtility2.concatUint8Arrays = concatUint8Arrays;
})(TarUtility || (TarUtility = {}));

// node_modules/@obsidize/tar-browserify/common/async-uint8-array-iterator.js
function sanitizeOptions(options) {
  return Object.assign({
    blockSize: Constants.SECTOR_SIZE * 16
    // 8Kb
  }, options);
}
var MIN_BLOCK_SIZE = Constants.SECTOR_SIZE;
var MAX_BLOCK_SIZE = Constants.SECTOR_SIZE * 1e4;
var AsyncUint8ArrayIterator = class {
  constructor(input, options = {}) {
    this.mOffset = 0;
    this.mInput = TarUtility.isUint8Array(input) ? new InMemoryAsyncUint8Array(input) : input;
    let { blockSize } = sanitizeOptions(options);
    blockSize = TarUtility.clamp(blockSize, MIN_BLOCK_SIZE, MAX_BLOCK_SIZE);
    blockSize = TarUtility.roundUpSectorOffset(blockSize);
    this.blockSize = blockSize;
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  get input() {
    return this.mInput;
  }
  get byteLength() {
    return this.mInput.byteLength;
  }
  get currentOffset() {
    return this.mOffset;
  }
  async tryNext() {
    var _a;
    const result = await this.next();
    return ((_a = result == null ? void 0 : result.value) == null ? void 0 : _a.buffer) ?? null;
  }
  /**
   * Grab the next `blockSize` chunk of data from the input.
   * See `AsyncIterableIterator` for more info.
   */
  async next() {
    const source = this.input;
    const offset = this.currentOffset;
    const length = this.byteLength;
    if (offset >= length) {
      return { done: true, value: null };
    }
    const targetLength = Math.min(this.blockSize, length - offset);
    const buffer = await source.read(offset, targetLength);
    this.mOffset += targetLength;
    return { done: false, value: { source, buffer, offset } };
  }
};

// node_modules/@obsidize/tar-browserify/header/ustar/ustar-header-field-type.js
var UstarHeaderFieldType;
(function(UstarHeaderFieldType2) {
  UstarHeaderFieldType2["ASCII"] = "ASCII";
  UstarHeaderFieldType2["ASCII_PADDED_END"] = "ASCII_PADDED_END";
  UstarHeaderFieldType2["INTEGER_OCTAL"] = "INTEGER_OCTAL";
  UstarHeaderFieldType2["INTEGER_OCTAL_TIMESTAMP"] = "INTEGER_OCTAL_TIMESTAMP";
})(UstarHeaderFieldType || (UstarHeaderFieldType = {}));

// node_modules/@obsidize/tar-browserify/header/ustar/ustar-header-field-transform.js
var UstarHeaderFieldTransformType;
(function(UstarHeaderFieldTransformType2) {
  function serializeIntegerOctalToString(value, maxLength) {
    return TarUtility.parseIntSafe(value).toString(Constants.OCTAL_RADIX).padStart(maxLength, "0").substring(0, maxLength);
  }
  function serializeIntegerOctalWithSuffix(value, fieldLength, suffix) {
    const adjustedLength = Math.max(0, fieldLength - 1 - suffix.length);
    const serializedString = serializeIntegerOctalToString(value, adjustedLength) + suffix;
    return TarUtility.encodeString(serializedString);
  }
  function getScopedBytes(input, fieldLength, offset) {
    return input.slice(offset, offset + fieldLength);
  }
  function serializeAscii(input, fieldLength) {
    return TarUtility.encodeString(String(input).substring(0, fieldLength));
  }
  function deserializeAscii(input, fieldLength, offset) {
    const bytes = getScopedBytes(input, fieldLength, offset);
    return TarUtility.decodeString(bytes);
  }
  function serializeAsciiPadded(input, fieldLength) {
    input = String(input);
    if (input.length > fieldLength) {
      return TarUtility.encodeString(input.substring(0, fieldLength - 1) + "\0");
    }
    return TarUtility.encodeString(input.padEnd(fieldLength, "\0"));
  }
  function deserializeAsciiPadded(input, fieldLength, offset) {
    const bytes = getScopedBytes(input, fieldLength, offset);
    return TarUtility.removeTrailingZeros(TarUtility.decodeString(bytes));
  }
  function serializeIntegerOctal(value, fieldLength) {
    return serializeIntegerOctalWithSuffix(value, fieldLength, " ");
  }
  function deserializeIntegerOctal(input, fieldLength, offset) {
    const bytes = getScopedBytes(input, fieldLength, offset);
    return TarUtility.parseIntSafe(TarUtility.decodeString(bytes).trim(), Constants.OCTAL_RADIX);
  }
  function serializeIntegerOctalTimestamp(value, fieldLength) {
    return serializeIntegerOctalWithSuffix(TarUtility.dateTimeToUstar(value), fieldLength, "");
  }
  function deserializeIntegerOctalTimestamp(input, fieldLength, offset) {
    return TarUtility.ustarTimeToDate(deserializeIntegerOctal(input, fieldLength, offset));
  }
  UstarHeaderFieldTransformType2.ASCII = Object.freeze({
    serialize: serializeAscii,
    deserialize: deserializeAscii
  });
  UstarHeaderFieldTransformType2.ASCII_PADDED_END = Object.freeze({
    serialize: serializeAsciiPadded,
    deserialize: deserializeAsciiPadded
  });
  UstarHeaderFieldTransformType2.INTEGER_OCTAL = Object.freeze({
    serialize: serializeIntegerOctal,
    deserialize: deserializeIntegerOctal
  });
  UstarHeaderFieldTransformType2.INTEGER_OCTAL_TIMESTAMP = Object.freeze({
    serialize: serializeIntegerOctalTimestamp,
    deserialize: deserializeIntegerOctalTimestamp
  });
  function from(fieldType) {
    switch (fieldType) {
      case UstarHeaderFieldType.ASCII:
        return UstarHeaderFieldTransformType2.ASCII;
      case UstarHeaderFieldType.ASCII_PADDED_END:
        return UstarHeaderFieldTransformType2.ASCII_PADDED_END;
      case UstarHeaderFieldType.INTEGER_OCTAL:
        return UstarHeaderFieldTransformType2.INTEGER_OCTAL;
      case UstarHeaderFieldType.INTEGER_OCTAL_TIMESTAMP:
        return UstarHeaderFieldTransformType2.INTEGER_OCTAL_TIMESTAMP;
      default:
        return void 0;
    }
  }
  UstarHeaderFieldTransformType2.from = from;
})(UstarHeaderFieldTransformType || (UstarHeaderFieldTransformType = {}));

// node_modules/@obsidize/tar-browserify/header/ustar/ustar-header-field.js
var UstarHeaderField = class _UstarHeaderField {
  constructor(config) {
    this.name = config.name;
    this.offset = config.offset;
    this.size = config.size;
    this.type = config.type;
    this.constantValue = config.constantValue || void 0;
    this.transform = UstarHeaderFieldTransformType.from(this.type);
  }
  static frozen(config) {
    return Object.freeze(new _UstarHeaderField(config));
  }
  static all() {
    return [
      _UstarHeaderField.fileName,
      _UstarHeaderField.fileMode,
      _UstarHeaderField.ownerUserId,
      _UstarHeaderField.groupUserId,
      _UstarHeaderField.fileSize,
      _UstarHeaderField.lastModified,
      _UstarHeaderField.headerChecksum,
      _UstarHeaderField.typeFlag,
      _UstarHeaderField.linkedFileName,
      _UstarHeaderField.ustarIndicator,
      _UstarHeaderField.ustarVersion,
      _UstarHeaderField.ownerUserName,
      _UstarHeaderField.ownerGroupName,
      _UstarHeaderField.deviceMajorNumber,
      _UstarHeaderField.deviceMinorNumber,
      _UstarHeaderField.fileNamePrefix
    ];
  }
  static checksumSet() {
    return _UstarHeaderField.all().filter((v) => v !== _UstarHeaderField.headerChecksum);
  }
  // =====================================================================
  // Instance Methods
  // =====================================================================
  /**
   * Shorthand for padding the output of `slice` into `decodeString`.
   */
  sliceString(input, offset) {
    return TarUtility.decodeString(this.slice(input, offset));
  }
  /**
   * @param input - a buffer of one or more complete tar sectors
   * @param offset - the offset to slice from (must be a multiple of `SECTOR_SIZE`)
   * @returns the slice of the given input Uint8Array that this field resides in.
   */
  slice(input, offset = 0) {
    if (!TarUtility.isUint8Array(input)) {
      return new Uint8Array(0);
    }
    const start = offset + this.offset;
    const end = start + this.size;
    return input.slice(start, end);
  }
  /**
   * @param input - a buffer of one or more complete tar sectors
   * @returns The value parsed from the input based on this field's transform type,
   * or `undefined` on error.
   */
  deserialize(input, offset = 0) {
    if (TarUtility.isUint8Array(input)) {
      return this.transform.deserialize(input, this.size, offset);
    }
    return void 0;
  }
  /**
   * @param input - the value to be serialized, based on this field's transform type.
   * @returns the serialized value as a Uint8Array
   */
  serialize(input) {
    const result = new Uint8Array(this.size);
    const value = this.transform.serialize(input, this.size);
    result.set(value, 0);
    return result;
  }
  /**
   * Runs `deserialize()` while also taking this field's offset into account.
   */
  readFrom(input, offset) {
    return this.deserialize(input, offset + this.offset);
  }
  /**
   * Serialize the given value and set the output bytes in the given output buffer.
   * @param output - the output buffer to be written to
   * @param headerOffset - the offset of the header in the output buffer to insert the update.
   * 		Note that this field's offset will be added to the header offset when inserting.
   * @param value - the value to be serialized
   * @returns true if the buffer was updated
   */
  writeTo(output, headerOffset, value) {
    headerOffset = Math.max(headerOffset, 0);
    const valueBytes = this.serialize(value);
    const valueByteLength = valueBytes.byteLength;
    const absoluteOffset = headerOffset + this.offset;
    if (valueByteLength > 0 && TarUtility.isUint8Array(output) && output.byteLength >= absoluteOffset + valueByteLength) {
      output.set(valueBytes, absoluteOffset);
      return true;
    }
    return false;
  }
  /**
   * Calculates the checksum value for this field in the given input buffer, at the given offset.
   * All field checksum values are aggregated together to form the main header checksum entry.
   * @param input - the input buffer to extract a field checksum from
   * @param offset - the offset of the header in the buffer (will be combined with this field's offset)
   * @returns the checksum value for this specific field
   */
  calculateChecksum(input, offset = 0) {
    let checksum = 0;
    if (!TarUtility.isUint8Array(input)) {
      return checksum;
    }
    const start = offset + this.offset;
    const end = start + this.size;
    for (let i = start; i < end; i++) {
      checksum += input[i];
    }
    return checksum;
  }
};
UstarHeaderField.fileName = UstarHeaderField.frozen({
  name: "fileName",
  offset: 0,
  size: 100,
  type: UstarHeaderFieldType.ASCII_PADDED_END
});
UstarHeaderField.fileMode = UstarHeaderField.frozen({
  name: "fileMode",
  offset: 100,
  size: 8,
  type: UstarHeaderFieldType.INTEGER_OCTAL
});
UstarHeaderField.ownerUserId = UstarHeaderField.frozen({
  name: "ownerUserId",
  offset: 108,
  size: 8,
  type: UstarHeaderFieldType.INTEGER_OCTAL
});
UstarHeaderField.groupUserId = UstarHeaderField.frozen({
  name: "groupUserId",
  offset: 116,
  size: 8,
  type: UstarHeaderFieldType.INTEGER_OCTAL
});
UstarHeaderField.fileSize = UstarHeaderField.frozen({
  name: "fileSize",
  offset: 124,
  size: 12,
  type: UstarHeaderFieldType.INTEGER_OCTAL
});
UstarHeaderField.lastModified = UstarHeaderField.frozen({
  name: "lastModified",
  offset: 136,
  size: 12,
  type: UstarHeaderFieldType.INTEGER_OCTAL_TIMESTAMP
});
UstarHeaderField.headerChecksum = UstarHeaderField.frozen({
  name: "headerChecksum",
  offset: 148,
  size: 8,
  type: UstarHeaderFieldType.INTEGER_OCTAL
});
UstarHeaderField.typeFlag = UstarHeaderField.frozen({
  name: "typeFlag",
  offset: 156,
  size: 1,
  type: UstarHeaderFieldType.ASCII
});
UstarHeaderField.linkedFileName = UstarHeaderField.frozen({
  name: "linkedFileName",
  offset: 157,
  size: 100,
  type: UstarHeaderFieldType.ASCII_PADDED_END
});
UstarHeaderField.ustarIndicator = UstarHeaderField.frozen({
  name: "ustarIndicator",
  offset: 257,
  size: 6,
  type: UstarHeaderFieldType.ASCII,
  constantValue: Constants.USTAR_INDICATOR_VALUE
});
UstarHeaderField.ustarVersion = UstarHeaderField.frozen({
  name: "ustarVersion",
  offset: 263,
  size: 2,
  type: UstarHeaderFieldType.ASCII,
  constantValue: Constants.USTAR_VERSION_VALUE
});
UstarHeaderField.ownerUserName = UstarHeaderField.frozen({
  name: "ownerUserName",
  offset: 265,
  size: 32,
  type: UstarHeaderFieldType.ASCII_PADDED_END
});
UstarHeaderField.ownerGroupName = UstarHeaderField.frozen({
  name: "ownerGroupName",
  offset: 297,
  size: 32,
  type: UstarHeaderFieldType.ASCII_PADDED_END
});
UstarHeaderField.deviceMajorNumber = UstarHeaderField.frozen({
  name: "deviceMajorNumber",
  offset: 329,
  size: 8,
  type: UstarHeaderFieldType.ASCII_PADDED_END
});
UstarHeaderField.deviceMinorNumber = UstarHeaderField.frozen({
  name: "deviceMinorNumber",
  offset: 337,
  size: 8,
  type: UstarHeaderFieldType.ASCII_PADDED_END
});
UstarHeaderField.fileNamePrefix = UstarHeaderField.frozen({
  name: "fileNamePrefix",
  offset: 345,
  size: 155,
  type: UstarHeaderFieldType.ASCII_PADDED_END
});

// node_modules/@obsidize/tar-browserify/header/pax/pax-header-key.js
var PaxHeaderKey;
(function(PaxHeaderKey2) {
  PaxHeaderKey2["ACCESS_TIME"] = "atime";
  PaxHeaderKey2["CHARSET"] = "charset";
  PaxHeaderKey2["COMMENT"] = "comment";
  PaxHeaderKey2["GROUP_ID"] = "gid";
  PaxHeaderKey2["GROUP_NAME"] = "gname";
  PaxHeaderKey2["HDR_CHARSET"] = "hdrcharset";
  PaxHeaderKey2["LINK_PATH"] = "linkpath";
  PaxHeaderKey2["MODIFICATION_TIME"] = "mtime";
  PaxHeaderKey2["PATH"] = "path";
  PaxHeaderKey2["SIZE"] = "size";
  PaxHeaderKey2["USER_ID"] = "uid";
  PaxHeaderKey2["USER_NAME"] = "uname";
})(PaxHeaderKey || (PaxHeaderKey = {}));

// node_modules/@obsidize/tar-browserify/header/pax/pax-header-segment.js
var ASCII_SPACE = 32;
var KEY_VALUE_SEPARATOR = "=";
var PaxHeaderSegment = class _PaxHeaderSegment {
  constructor(mKey = "", mValue = "", mBytes = null) {
    this.mKey = mKey;
    this.mValue = mValue;
    this.mBytes = mBytes;
  }
  static serialize(key, value) {
    if (!key || !value) {
      return new Uint8Array(0);
    }
    const segmentSuffix = ` ${key}=${value}
`;
    const preCalculatedLength = segmentSuffix.length.toString().length;
    let segmentLength = segmentSuffix.length + preCalculatedLength;
    if (segmentLength < segmentLength.toString().length + segmentSuffix.length) {
      segmentLength += 1;
    }
    const segment = segmentLength.toString() + segmentSuffix;
    return TarUtility.encodeString(segment);
  }
  static deserialize(bytes, offset = 0) {
    if (!TarUtility.isUint8Array(bytes)) {
      return null;
    }
    const lengthEndIndex = _PaxHeaderSegment.findNextLengthEndIndex(bytes, offset);
    if (lengthEndIndex < 0) {
      return null;
    }
    const segmentLengthStr = TarUtility.decodeString(bytes.slice(offset, lengthEndIndex));
    const segmentLength = parseInt(segmentLengthStr, 10);
    if (isNaN(segmentLength)) {
      return null;
    }
    const kvpStart = lengthEndIndex + 1;
    const kvpEnd = offset + segmentLength;
    const kvpData = TarUtility.decodeString(bytes.slice(kvpStart, kvpEnd));
    const equalsDelimiterIndex = kvpData.indexOf(KEY_VALUE_SEPARATOR);
    const key = kvpData.substring(0, equalsDelimiterIndex);
    const value = kvpData.substring(equalsDelimiterIndex + 1).replace(/\n$/, "");
    const segmentBytes = TarUtility.cloneUint8Array(bytes, offset, offset + segmentLength);
    return new _PaxHeaderSegment(key, value, segmentBytes);
  }
  static findNextLengthEndIndex(bytes, offset) {
    let lengthEnd = offset + 1;
    while (lengthEnd < bytes.byteLength) {
      if (bytes[lengthEnd] === ASCII_SPACE) {
        return lengthEnd;
      } else {
        lengthEnd += 1;
      }
    }
    return -1;
  }
  get key() {
    return this.mKey;
  }
  get value() {
    return this.mValue;
  }
  get bytes() {
    return this.toUint8Array();
  }
  /**
   * the value parsed as an integer, or undefined if the parse operation fails
   */
  get intValue() {
    const parsed = parseInt(this.value);
    return isNaN(parsed) ? void 0 : parsed;
  }
  /**
   * the value parsed as a float, or undefined if the parse operation fails
   */
  get floatValue() {
    const parsed = parseFloat(this.value);
    return isNaN(parsed) ? void 0 : parsed;
  }
  toUint8Array() {
    if (!TarUtility.isUint8Array(this.mBytes)) {
      this.mBytes = _PaxHeaderSegment.serialize(this.key, this.value);
    }
    return this.mBytes;
  }
  toJSON() {
    const { key, value, bytes } = this;
    const content = TarUtility.getDebugHexString(bytes);
    return {
      key,
      value,
      content
    };
  }
};

// node_modules/@obsidize/tar-browserify/header/pax/pax-header-utility.js
var PaxHeaderUtility;
(function(PaxHeaderUtility2) {
  const knownKeys = [
    PaxHeaderKey.COMMENT,
    PaxHeaderKey.GROUP_ID,
    PaxHeaderKey.GROUP_NAME,
    PaxHeaderKey.HDR_CHARSET,
    PaxHeaderKey.LINK_PATH,
    PaxHeaderKey.MODIFICATION_TIME,
    PaxHeaderKey.PATH,
    PaxHeaderKey.SIZE,
    PaxHeaderKey.USER_ID,
    PaxHeaderKey.USER_NAME
  ];
  function isKnownHeaderKey(key) {
    return knownKeys.includes(key);
  }
  PaxHeaderUtility2.isKnownHeaderKey = isKnownHeaderKey;
})(PaxHeaderUtility || (PaxHeaderUtility = {}));

// node_modules/@obsidize/tar-browserify/header/pax/pax-header.js
var PaxHeader = class _PaxHeader {
  constructor(segments = []) {
    this.valueMap = {};
    for (const segment of segments) {
      this.valueMap[segment.key] = segment;
    }
  }
  static deserialize(buffer, offset = 0) {
    const segments = _PaxHeader.deserializeSegments(buffer, offset);
    return new _PaxHeader(segments);
  }
  static fromAttributes(attributes) {
    const segments = _PaxHeader.parseSegmentsFromAttributes(attributes);
    return new _PaxHeader(segments);
  }
  static serializeAttributes(attributes) {
    const segments = _PaxHeader.parseSegmentsFromAttributes(attributes);
    return _PaxHeader.serializeSegments(segments);
  }
  static parseSegmentsFromAttributes(attributes) {
    if (!TarUtility.isObject(attributes)) {
      return [];
    }
    const segments = [];
    for (const [key, value] of Object.entries(attributes)) {
      const strVal = TarUtility.isString(value) ? value : String(value);
      segments.push(new PaxHeaderSegment(key, strVal));
    }
    return segments;
  }
  static serializeSegments(segments) {
    if (!Array.isArray(segments) || segments.length <= 0) {
      return new Uint8Array(0);
    }
    let totalLength = 0;
    let segmentBuffers = [];
    for (const segment of segments) {
      const encodedSegment = segment.toUint8Array();
      segmentBuffers.push(encodedSegment);
      totalLength += encodedSegment.byteLength;
    }
    const resultBuffer = new Uint8Array(totalLength);
    let offset = 0;
    for (const segmentBuffer of segmentBuffers) {
      resultBuffer.set(segmentBuffer, offset);
      offset += segmentBuffer.byteLength;
    }
    return resultBuffer;
  }
  /**
   * Wraps the given file name (if necessary) with the 'PaxHeader' metadata indicator.
   * If the indicator already exists in the given file name, this does nothing.
   */
  static wrapFileName(fileName) {
    if (!TarUtility.isString(fileName) || fileName.includes(Constants.PAX_HEADER_PREFIX)) {
      return fileName;
    }
    let sepIndex = fileName.lastIndexOf("/");
    if (sepIndex >= 0) {
      return _PaxHeader.insertPaxAt(fileName, "/", sepIndex);
    }
    sepIndex = fileName.lastIndexOf("\\");
    if (sepIndex >= 0) {
      return _PaxHeader.insertPaxAt(fileName, "\\", sepIndex);
    }
    return _PaxHeader.makeTopLevelPrefix(fileName, "/", 0);
  }
  static insertPaxAt(fileName, separator, offset) {
    const maxLength = UstarHeaderField.fileName.size;
    if (fileName.length < maxLength) {
      return fileName.substring(0, offset) + separator + Constants.PAX_HEADER_PREFIX + fileName.substring(offset);
    }
    return _PaxHeader.makeTopLevelPrefix(fileName, "/", offset + 1);
  }
  static makeTopLevelPrefix(fileName, separator, offset) {
    const maxLength = UstarHeaderField.fileName.size;
    let result = Constants.PAX_HEADER_PREFIX + separator + fileName.substring(offset);
    if (result.length > maxLength) {
      result = result.substring(0, maxLength - 2) + "\0\0";
    }
    return result;
  }
  static deserializeSegments(buffer, offset) {
    const result = [];
    let cursor = offset;
    let next = PaxHeaderSegment.deserialize(buffer, cursor);
    while (next !== null) {
      result.push(next);
      cursor += next.bytes.byteLength;
      next = PaxHeaderSegment.deserialize(buffer, cursor);
    }
    return result;
  }
  /**
   * See `PaxHeaderKey.ACCESS_TIME` for more info
   */
  get accessTime() {
    return this.getFloat(PaxHeaderKey.ACCESS_TIME);
  }
  /**
   * See `PaxHeaderKey.CHARSET` for more info
   */
  get charset() {
    return this.get(PaxHeaderKey.CHARSET);
  }
  /**
   * See `PaxHeaderKey.COMMENT` for more info
   */
  get comment() {
    return this.get(PaxHeaderKey.COMMENT);
  }
  /**
   * See `PaxHeaderKey.GROUP_ID` for more info
   */
  get groupId() {
    return this.getInt(PaxHeaderKey.GROUP_ID);
  }
  /**
   * See `PaxHeaderKey.GROUP_NAME` for more info
   */
  get groupName() {
    return this.get(PaxHeaderKey.GROUP_NAME);
  }
  /**
   * See `PaxHeaderKey.HDR_CHARSET` for more info
   */
  get hdrCharset() {
    return this.get(PaxHeaderKey.HDR_CHARSET);
  }
  /**
   * See `PaxHeaderKey.LINK_PATH` for more info
   */
  get linkPath() {
    return this.get(PaxHeaderKey.LINK_PATH);
  }
  /**
   * See `PaxHeaderKey.MODIFICATION_TIME` for more info
   */
  get modificationTime() {
    return this.getFloat(PaxHeaderKey.MODIFICATION_TIME);
  }
  /**
   * See `PaxHeaderKey.PATH` for more info
   */
  get path() {
    return this.get(PaxHeaderKey.PATH);
  }
  /**
   * See `PaxHeaderKey.SIZE` for more info
   */
  get size() {
    return this.getInt(PaxHeaderKey.SIZE);
  }
  /**
   * See `PaxHeaderKey.USER_ID` for more info
   */
  get userId() {
    return this.getInt(PaxHeaderKey.USER_ID);
  }
  /**
   * See `PaxHeaderKey.USER_NAME` for more info
   */
  get userName() {
    return this.get(PaxHeaderKey.USER_NAME);
  }
  /**
   * Converts modificationTime to standard javascript epoch time.
   */
  get lastModified() {
    const mtime = this.modificationTime;
    return mtime ? TarUtility.paxTimeToDate(mtime) : void 0;
  }
  /**
   * @returns an array of the keys in this header
   */
  keys() {
    return Object.keys(this.valueMap);
  }
  /**
   * @returns an array of the segments in this header
   */
  values() {
    return Object.values(this.valueMap);
  }
  /**
   * Removes any unknown or un-standardized keys from this header.
   * @returns `this` for operation chaining
   */
  clean() {
    for (const key of this.keys()) {
      if (!PaxHeaderUtility.isKnownHeaderKey(key)) {
        delete this.valueMap[key];
      }
    }
    return this;
  }
  /**
   * @returns true if the value map of this parsed header contains the given key
   */
  has(key) {
    return TarUtility.isDefined(this.valueMap[key]);
  }
  /**
   * @returns the value parsed from the bytes of this header for the given key,
   * or `undefined` if the key did not exist in the header.
   */
  get(key) {
    var _a;
    return (_a = this.valueMap[key]) == null ? void 0 : _a.value;
  }
  /**
   * Parse the value for the given key as an int.
   * @returns undefined if the key does not exist or the parse operation fails.
   */
  getInt(key) {
    var _a;
    return (_a = this.valueMap[key]) == null ? void 0 : _a.intValue;
  }
  /**
   * Parse the value for the given key as a float.
   * @returns undefined if the key does not exist or the parse operation fails.
   */
  getFloat(key) {
    var _a;
    return (_a = this.valueMap[key]) == null ? void 0 : _a.floatValue;
  }
  /**
   * Serializes the underlying value map of this instance into a set of PAX sectors.
   */
  toUint8Array() {
    return _PaxHeader.serializeSegments(this.values());
  }
  /**
   * Adds any necessary padding to the serialized output to ensure the length
   * of the output is a multiple of `SECTOR_SIZE`.
   *
   * See `toUint8Array()` for more info.
   */
  toUint8ArrayPadded() {
    const serializedBuffer = this.toUint8Array();
    let delta = TarUtility.getSectorOffsetDelta(serializedBuffer.byteLength);
    if (delta > 0) {
      return TarUtility.concatUint8Arrays(serializedBuffer, new Uint8Array(delta));
    }
    return serializedBuffer;
  }
  toJSON() {
    const { valueMap: attributes } = this;
    const bytes = this.toUint8Array();
    const buffer = TarUtility.getDebugBufferJson(bytes);
    return {
      attributes,
      buffer
    };
  }
};

// node_modules/@obsidize/tar-browserify/header/ustar/ustar-header-link-indicator-type.js
var UstarHeaderLinkIndicatorType;
(function(UstarHeaderLinkIndicatorType2) {
  UstarHeaderLinkIndicatorType2["UNKNOWN"] = "UNKNOWN";
  UstarHeaderLinkIndicatorType2["NORMAL_FILE"] = "0";
  UstarHeaderLinkIndicatorType2["NORMAL_FILE_ALT1"] = "\0";
  UstarHeaderLinkIndicatorType2["NORMAL_FILE_ALT2"] = "";
  UstarHeaderLinkIndicatorType2["HARD_LINK"] = "1";
  UstarHeaderLinkIndicatorType2["SYMBOLIC_LINK"] = "2";
  UstarHeaderLinkIndicatorType2["CHARACTER_SPECIAL"] = "3";
  UstarHeaderLinkIndicatorType2["BLOCK_SPECIAL"] = "4";
  UstarHeaderLinkIndicatorType2["DIRECTORY"] = "5";
  UstarHeaderLinkIndicatorType2["FIFO"] = "6";
  UstarHeaderLinkIndicatorType2["CONTIGUOUS_FILE"] = "7";
  UstarHeaderLinkIndicatorType2["GLOBAL_EXTENDED_HEADER"] = "g";
  UstarHeaderLinkIndicatorType2["LOCAL_EXTENDED_HEADER"] = "x";
})(UstarHeaderLinkIndicatorType || (UstarHeaderLinkIndicatorType = {}));

// node_modules/@obsidize/tar-browserify/header/tar-header-utility.js
var TarHeaderUtility;
(function(TarHeaderUtility2) {
  TarHeaderUtility2.CHECKSUM_SEED_STRING = "".padStart(UstarHeaderField.headerChecksum.size, " ");
  TarHeaderUtility2.CHECKSUM_SEED = TarUtility.generateChecksum(TarUtility.encodeString(TarHeaderUtility2.CHECKSUM_SEED_STRING));
  TarHeaderUtility2.ALL_FIELDS = UstarHeaderField.all();
  TarHeaderUtility2.CHECKSUM_FIELDS = UstarHeaderField.checksumSet();
  function isUstarSector(input, offset) {
    return UstarHeaderField.ustarIndicator.sliceString(input, offset).startsWith(Constants.USTAR_TAG);
  }
  TarHeaderUtility2.isUstarSector = isUstarSector;
  function isTarHeaderLinkIndicatorTypeDirectory(type) {
    return type === UstarHeaderLinkIndicatorType.DIRECTORY;
  }
  TarHeaderUtility2.isTarHeaderLinkIndicatorTypeDirectory = isTarHeaderLinkIndicatorTypeDirectory;
  function isTarHeaderLinkIndicatorTypeFile(type) {
    switch (type) {
      case UstarHeaderLinkIndicatorType.NORMAL_FILE:
      case UstarHeaderLinkIndicatorType.NORMAL_FILE_ALT1:
      case UstarHeaderLinkIndicatorType.NORMAL_FILE_ALT2:
      case UstarHeaderLinkIndicatorType.CONTIGUOUS_FILE:
        return true;
      default:
        return false;
    }
  }
  TarHeaderUtility2.isTarHeaderLinkIndicatorTypeFile = isTarHeaderLinkIndicatorTypeFile;
  function isTarHeaderLinkIndicatorTypePax(type) {
    switch (type) {
      case UstarHeaderLinkIndicatorType.LOCAL_EXTENDED_HEADER:
      case UstarHeaderLinkIndicatorType.GLOBAL_EXTENDED_HEADER:
        return true;
      default:
        return false;
    }
  }
  TarHeaderUtility2.isTarHeaderLinkIndicatorTypePax = isTarHeaderLinkIndicatorTypePax;
  function findNextUstarSectorOffset(input, offset = 0) {
    const NOT_FOUND = -1;
    if (!TarUtility.isUint8Array(input)) {
      return NOT_FOUND;
    }
    const maxOffset = input.byteLength;
    let nextOffset = Math.max(0, offset);
    while (nextOffset < maxOffset && !isUstarSector(input, nextOffset)) {
      nextOffset = TarUtility.advanceSectorOffset(nextOffset, maxOffset);
    }
    if (nextOffset < maxOffset) {
      return nextOffset;
    }
    return NOT_FOUND;
  }
  TarHeaderUtility2.findNextUstarSectorOffset = findNextUstarSectorOffset;
})(TarHeaderUtility || (TarHeaderUtility = {}));

// node_modules/@obsidize/tar-browserify/header/ustar/ustar-header.js
var UstarHeader = class _UstarHeader {
  constructor(attributes = {}) {
    this.mValueMap = _UstarHeader.defaultValues();
    this.update(attributes);
  }
  static isUstarHeader(value) {
    return !!(value && value instanceof _UstarHeader);
  }
  /**
   * @returns A new `UstarHeader` instance based on the given attributes (if they are a POJO).
   * Note that if the given value is already a UstarHeader instance, this will return it as-is.
   */
  static fromAttributes(attributes) {
    return _UstarHeader.isUstarHeader(attributes) ? attributes : new _UstarHeader(attributes);
  }
  /**
   * Short-hand for constructing a new `UstarHeader` and immediately calling `toUint8Array()` on it
   */
  static serializeAttributes(attributes) {
    return _UstarHeader.fromAttributes(attributes).toUint8Array();
  }
  /**
   * Parses out a UstarHeader instance from the given input buffer, at the given offset.
   * The given offset must be a multiple of SECTOR_SIZE.
   *
   * If the sector at the given offset is not marked with a ustar indicator,
   * this will return null.
   */
  static deserialize(input, offset = 0) {
    if (!TarHeaderUtility.isUstarSector(input, offset)) {
      return null;
    }
    const attributes = {};
    for (const field of TarHeaderUtility.ALL_FIELDS) {
      attributes[field.name] = field.readFrom(input, offset);
    }
    return new _UstarHeader(attributes);
  }
  static defaultValues() {
    return {
      fileName: "",
      fileMode: Constants.FILE_MODE_DEFAULT,
      groupUserId: 0,
      ownerUserId: 0,
      fileSize: 0,
      lastModified: TarUtility.getUstarTimestamp(),
      headerChecksum: 0,
      linkedFileName: "",
      typeFlag: UstarHeaderLinkIndicatorType.NORMAL_FILE,
      ustarIndicator: Constants.USTAR_INDICATOR_VALUE,
      ustarVersion: Constants.USTAR_VERSION_VALUE,
      ownerUserName: "",
      ownerGroupName: "",
      deviceMajorNumber: "00",
      deviceMinorNumber: "00",
      fileNamePrefix: ""
    };
  }
  get fileName() {
    return this.mValueMap.fileName;
  }
  set fileName(value) {
    this.mValueMap.fileName = value;
  }
  get fileMode() {
    return this.mValueMap.fileMode;
  }
  set fileMode(value) {
    this.mValueMap.fileMode = value;
  }
  get ownerUserId() {
    return this.mValueMap.ownerUserId;
  }
  set ownerUserId(value) {
    this.mValueMap.ownerUserId = value;
  }
  get groupUserId() {
    return this.mValueMap.groupUserId;
  }
  set groupUserId(value) {
    this.mValueMap.groupUserId = value;
  }
  get fileSize() {
    return this.mValueMap.fileSize;
  }
  set fileSize(value) {
    this.mValueMap.fileSize = value;
  }
  get lastModified() {
    return this.mValueMap.lastModified;
  }
  set lastModified(value) {
    this.mValueMap.lastModified = TarUtility.sanitizeDateTimeAsUstar(value);
  }
  get headerChecksum() {
    return this.mValueMap.headerChecksum;
  }
  set headerChecksum(value) {
    this.mValueMap.headerChecksum = value;
  }
  get linkedFileName() {
    return this.mValueMap.linkedFileName;
  }
  set linkedFileName(value) {
    this.mValueMap.linkedFileName = value;
  }
  get typeFlag() {
    return this.mValueMap.typeFlag;
  }
  set typeFlag(value) {
    this.mValueMap.typeFlag = value;
  }
  get ustarIndicator() {
    return this.mValueMap.ustarIndicator;
  }
  get ustarVersion() {
    return this.mValueMap.ustarVersion;
  }
  set ustarVersion(value) {
    this.mValueMap.ustarVersion = value;
  }
  get ownerUserName() {
    return this.mValueMap.ownerUserName;
  }
  set ownerUserName(value) {
    this.mValueMap.ownerUserName = value;
  }
  get ownerGroupName() {
    return this.mValueMap.ownerGroupName;
  }
  set ownerGroupName(value) {
    this.mValueMap.ownerGroupName = value;
  }
  get deviceMajorNumber() {
    return this.mValueMap.deviceMajorNumber;
  }
  set deviceMajorNumber(value) {
    this.mValueMap.deviceMajorNumber = value;
  }
  get deviceMinorNumber() {
    return this.mValueMap.deviceMinorNumber;
  }
  set deviceMinorNumber(value) {
    this.mValueMap.deviceMinorNumber = value;
  }
  get fileNamePrefix() {
    return this.mValueMap.fileNamePrefix;
  }
  set fileNamePrefix(value) {
    this.mValueMap.fileNamePrefix = value;
  }
  get isPaxHeader() {
    return this.isLocalPaxHeader || this.isGlobalPaxHeader;
  }
  get isGlobalPaxHeader() {
    return this.typeFlag === UstarHeaderLinkIndicatorType.GLOBAL_EXTENDED_HEADER;
  }
  get isLocalPaxHeader() {
    return this.typeFlag === UstarHeaderLinkIndicatorType.LOCAL_EXTENDED_HEADER;
  }
  get isFileHeader() {
    return TarHeaderUtility.isTarHeaderLinkIndicatorTypeFile(this.typeFlag);
  }
  get isDirectoryHeader() {
    return TarHeaderUtility.isTarHeaderLinkIndicatorTypeDirectory(this.typeFlag);
  }
  update(attributes) {
    Object.assign(this.mValueMap, attributes);
    return this;
  }
  toAttributes() {
    return Object.assign({}, this.mValueMap);
  }
  toUint8Array() {
    const result = new Uint8Array(Constants.HEADER_SIZE);
    let checksum = TarHeaderUtility.CHECKSUM_SEED;
    for (const field of TarHeaderUtility.CHECKSUM_FIELDS) {
      field.writeTo(result, 0, this.mValueMap[field.name]);
      checksum += field.calculateChecksum(result);
    }
    this.headerChecksum = checksum;
    UstarHeaderField.headerChecksum.writeTo(result, 0, checksum);
    return result;
  }
  toJSON() {
    const attributes = this.toAttributes();
    const bytes = this.toUint8Array();
    const buffer = TarUtility.getDebugBufferJson(bytes);
    return {
      attributes,
      buffer
    };
  }
};

// node_modules/@obsidize/tar-browserify/header/tar-header.js
var TarHeader = class _TarHeader {
  constructor(options) {
    const { ustar, pax, preamble, isPaxGlobal } = options;
    this.ustar = ustar;
    this.pax = pax;
    this.mPreamble = preamble;
    this.mIsGlobal = !!isPaxGlobal;
    this.trySyncPaxHeader();
  }
  static isTarHeader(value) {
    return !!(value && value instanceof _TarHeader);
  }
  /**
   * @returns A new `TarHeader` instance based on the given attributes (if they are a POJO).
   * Note that if the given value is already a TarHeader instance, this will return it as-is.
   */
  static fromAttributes(attributes) {
    if (_TarHeader.isTarHeader(attributes)) {
      return attributes;
    }
    const ustar = new UstarHeader(attributes);
    const paxRequiredAttributes = _TarHeader.collectPaxRequiredAttributes(attributes);
    let pax;
    if (paxRequiredAttributes) {
      const [directoryName, fileName] = _TarHeader.splitBaseFileName(paxRequiredAttributes.path);
      ustar.fileName = fileName;
      ustar.fileNamePrefix = directoryName;
      pax = PaxHeader.fromAttributes(paxRequiredAttributes);
    }
    return new _TarHeader({ ustar, pax });
  }
  /**
   * Short-hand for constructing a new `TarHeader` and immediately calling `toUint8Array()` on it
   */
  static serializeAttributes(attributes) {
    if (_TarHeader.isTarHeader(attributes)) {
      return attributes.toUint8Array();
    }
    return _TarHeader.fromAttributes(attributes).toUint8Array();
  }
  static collectPaxRequiredAttributes(attributes) {
    if (TarUtility.isObject(attributes)) {
      let collected = {};
      if (attributes.fileName && attributes.fileName.length > UstarHeaderField.fileName.size) {
        collected.path = attributes.fileName;
      }
      if (Object.keys(collected).length > 0) {
        return collected;
      }
    }
    return null;
  }
  static splitBaseFileName(fileName) {
    let offset = fileName.lastIndexOf("/");
    if (offset >= 0) {
      return [fileName.substring(0, offset), fileName.substring(offset + 1)];
    }
    offset = fileName.lastIndexOf("\\");
    if (offset >= 0) {
      return [fileName.substring(0, offset), fileName.substring(offset + 1)];
    }
    return ["", fileName];
  }
  get preamble() {
    return this.mPreamble;
  }
  get fileName() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.path) || this.ustar.fileName;
  }
  get fileMode() {
    return this.ustar.fileMode;
  }
  get ownerUserId() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.userId) || this.ustar.ownerUserId;
  }
  get groupUserId() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.groupId) || this.ustar.groupUserId;
  }
  get fileSize() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.size) || this.ustar.fileSize;
  }
  get lastModified() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.lastModified) || this.ustar.lastModified;
  }
  get headerChecksum() {
    return this.ustar.headerChecksum;
  }
  get linkedFileName() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.linkPath) || this.ustar.linkedFileName;
  }
  get typeFlag() {
    return this.ustar.typeFlag;
  }
  get ustarIndicator() {
    return this.ustar.ustarIndicator;
  }
  get ustarVersion() {
    return this.ustar.ustarVersion;
  }
  get ownerUserName() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.userName) || this.ustar.ownerUserName;
  }
  get ownerGroupName() {
    var _a;
    return ((_a = this.pax) == null ? void 0 : _a.groupName) || this.ustar.ownerGroupName;
  }
  get deviceMajorNumber() {
    return this.ustar.deviceMajorNumber;
  }
  get deviceMinorNumber() {
    return this.ustar.deviceMinorNumber;
  }
  get fileNamePrefix() {
    return this.ustar.fileNamePrefix;
  }
  get isPaxHeader() {
    return this.isLocalPaxHeader || this.isGlobalPaxHeader;
  }
  get isGlobalPaxHeader() {
    return this.isGlobalPaxPreHeader || this.isGlobalPaxPostHeader;
  }
  get isLocalPaxHeader() {
    return this.isLocalPaxPreHeader || this.isLocalPaxPostHeader;
  }
  get isGlobalPaxPreHeader() {
    return this.ustar.isGlobalPaxHeader;
  }
  get isLocalPaxPreHeader() {
    return this.ustar.isLocalPaxHeader;
  }
  get isGlobalPaxPostHeader() {
    var _a;
    return ((_a = this.preamble) == null ? void 0 : _a.isGlobalPaxHeader) ?? false;
  }
  get isLocalPaxPostHeader() {
    var _a;
    return ((_a = this.preamble) == null ? void 0 : _a.isLocalPaxHeader) ?? false;
  }
  get isFileHeader() {
    return this.ustar.isFileHeader;
  }
  get isDirectoryHeader() {
    return this.ustar.isDirectoryHeader;
  }
  /**
   * Removes any unknown or un-standardized keys from
   * the PAX portion of this header (if one exists).
   *
   * See also `PaxHeader.clean()`.
   *
   * @returns `this` for operation chaining
   */
  clean() {
    var _a;
    (_a = this.pax) == null ? void 0 : _a.clean();
    return this;
  }
  /**
   * Ensures that things such as checksum values are
   * synchronized with the current underlying header states.
   *
   * @returns `this` for operation chaining
   */
  normalize() {
    this.trySyncPaxHeader();
    return this;
  }
  /**
   * @returns A snapshot of the underlying buffer for this header
   */
  toUint8Array() {
    this.normalize();
    const isPax = !!(this.isPaxHeader && this.pax && this.preamble);
    if (!isPax) {
      return this.ustar.toUint8Array();
    }
    const preambleBytes = this.preamble.toUint8Array();
    const paxBytes = this.pax.toUint8ArrayPadded();
    const ownBytes = this.ustar.toUint8Array();
    const totalSize = preambleBytes.byteLength + paxBytes.byteLength + ownBytes.byteLength;
    const result = new Uint8Array(totalSize);
    let offset = 0;
    result.set(preambleBytes, offset);
    offset += preambleBytes.byteLength;
    result.set(paxBytes, offset);
    offset += paxBytes.byteLength;
    result.set(ownBytes, offset);
    return result;
  }
  toJSON() {
    const { pax, preamble, ustar } = this;
    return { preamble, pax, ustar };
  }
  trySyncPaxHeader() {
    if (!this.pax) {
      return;
    }
    const fileName = this.fileName;
    const fileSize = this.pax.toUint8Array().byteLength;
    const lastModified = this.pax.lastModified;
    const typeFlag = this.mIsGlobal ? UstarHeaderLinkIndicatorType.GLOBAL_EXTENDED_HEADER : UstarHeaderLinkIndicatorType.LOCAL_EXTENDED_HEADER;
    const preambleAttrs = {
      fileName,
      typeFlag,
      lastModified,
      fileSize
    };
    if (this.mPreamble) {
      this.mPreamble.update(preambleAttrs);
    } else {
      this.mPreamble = new UstarHeader(preambleAttrs);
    }
  }
};

// node_modules/@obsidize/tar-browserify/archive/archive-entry.js
var ArchiveEntry = class _ArchiveEntry {
  constructor(options = {}) {
    let { header, headerAttributes, headerByteLength, content, offset, context } = options;
    if (!header)
      header = TarHeader.fromAttributes(headerAttributes || {});
    if (!content)
      content = null;
    if (!offset)
      offset = 0;
    if (!context)
      context = null;
    const contentLength = TarUtility.sizeofUint8Array(content);
    if (!header.pax && header.fileSize !== contentLength && contentLength > 0) {
      header.ustar.fileSize = contentLength;
    }
    if (!headerByteLength)
      headerByteLength = header.toUint8Array().byteLength;
    this.mHeader = header;
    this.mHeaderByteLength = headerByteLength;
    this.mContent = content;
    this.mOffset = offset;
    this.mContext = context;
  }
  static isArchiveEntry(v) {
    return !!(v && v instanceof _ArchiveEntry);
  }
  // =================================================================
  // TarHeader Interface Fields
  // =================================================================
  get fileName() {
    return this.header.fileName;
  }
  get fileSize() {
    return this.header.fileSize;
  }
  get fileMode() {
    return this.header.fileMode;
  }
  get ownerUserId() {
    return this.header.ownerUserId;
  }
  get groupUserId() {
    return this.header.groupUserId;
  }
  get lastModified() {
    return this.header.lastModified;
  }
  get headerChecksum() {
    return this.header.headerChecksum;
  }
  get linkedFileName() {
    return this.header.linkedFileName;
  }
  get typeFlag() {
    return this.header.typeFlag;
  }
  get ustarIndicator() {
    return this.header.ustarIndicator;
  }
  get ustarVersion() {
    return this.header.ustarVersion;
  }
  get ownerUserName() {
    return this.header.ownerUserName;
  }
  get ownerGroupName() {
    return this.header.ownerGroupName;
  }
  get deviceMajorNumber() {
    return this.header.deviceMajorNumber;
  }
  get deviceMinorNumber() {
    return this.header.deviceMinorNumber;
  }
  get fileNamePrefix() {
    return this.header.fileNamePrefix;
  }
  // =================================================================
  // Introspection Fields
  // =================================================================
  /**
   * The header metadata parsed out for this entry.
   * If you are attempting to read the content of this entry,
   * do not modify this instance.
   */
  get header() {
    return this.mHeader;
  }
  /**
   * The file content for this entry.
   * This may be null for entries loaded asynchronously, or
   * for non-file entries like directories.
   */
  get content() {
    return this.mContent;
  }
  /**
   * The starting absolute index (inclusive) in the source buffer that this entry was parsed from.
   * Returns zero by default if this was not parsed by a source buffer.
   */
  get sourceOffset() {
    return this.mOffset;
  }
  /**
   * The size in bytes of the header in the source buffer that this entry was parsed from.
   * Returns zero by default if this was not parsed by a source buffer.
   */
  get sourceHeaderByteLength() {
    return this.mHeaderByteLength;
  }
  /**
   * The context (if any) from which this entry was parsed.
   * The context will include global data about things such as
   * the origin of the archive and global pax headers.
   */
  get sourceContext() {
    return this.mContext;
  }
  isDirectory() {
    return this.header.isDirectoryHeader;
  }
  isFile() {
    return this.header.isFileHeader;
  }
  /**
   * Convenience for decoding the current content buffer as a string.
   * Note that if the content was not loaded for whatever reason, this
   * will return an empty string.
   * @returns The decoded string data from the currently assigned content,
   * or an empty string if there is no content assigned.
   */
  text() {
    return TarUtility.decodeString(this.content);
  }
  /**
   * Only necessary if this entry was extracted from an async buffer, since the entry
   * does not hold the content of async buffers by default.
   *
   * If the entry was extracted synchronously, its content will be available via the "content" property.
   *
   * Do not use this on entries that have not been parsed from a source buffer,
   * otherwise it will very likely return garbage data.
   *
   * @param buffer - the source to read content from
   * @param offset - the _relative_ offset of the content to read;
   * 					setting this to 42 will start reading at the 42nd byte index within the content block
   * @param length - the number of bytes to read after the offset
   */
  async readContentFrom(buffer, offset = 0, length = 0) {
    const fileSize = this.fileSize;
    const contentStartIndex = this.sourceOffset + this.sourceHeaderByteLength;
    const contentEndIndex = contentStartIndex + fileSize;
    const absoluteOffset = contentStartIndex + TarUtility.clamp(offset, 0, fileSize);
    const bytesRemaining = Math.max(0, contentEndIndex - absoluteOffset);
    const normalizedLength = length > 0 ? Math.min(length, bytesRemaining) : bytesRemaining;
    return buffer.read(absoluteOffset, normalizedLength);
  }
  /**
   * @returns This instance serialized as a single slice for a tar buffer
   */
  toUint8Array() {
    var _a;
    const headerBytes = this.header.toUint8Array();
    const contentLength = ((_a = this.content) == null ? void 0 : _a.byteLength) ?? 0;
    const outputLength = TarUtility.roundUpSectorOffset(headerBytes.byteLength + contentLength);
    const result = new Uint8Array(outputLength);
    result.set(headerBytes, 0);
    if (contentLength > 0) {
      result.set(this.content, headerBytes.byteLength);
    }
    return result;
  }
  /**
   * Overridden to prevent circular reference errors / huge memory spikes that would
   * include the underlying content by default.
   */
  toJSON() {
    const { header, fileName: name, fileSize: size, content } = this;
    const isFile = this.isFile();
    const isDirectory = this.isDirectory();
    const type = isFile ? "file" : isDirectory ? "directory" : "complex";
    const contentType = content ? "Uint8Array[" + content.byteLength + "]" : "null";
    return {
      name,
      size,
      type,
      header,
      contentType,
      content: TarUtility.getDebugHexString(content)
    };
  }
};

// node_modules/@obsidize/tar-browserify/archive/archive-reader.js
var MAX_LOADED_BYTES = Constants.SECTOR_SIZE * 1e5;
var ArchiveReadError;
(function(ArchiveReadError2) {
  ArchiveReadError2["ERR_ENTRY_CONTENT_MIN_BUFFER_LENGTH_NOT_MET"] = "ERR_ENTRY_CONTENT_MIN_BUFFER_LENGTH_NOT_MET";
  ArchiveReadError2["ERR_HEADER_PAX_MIN_BUFFER_LENGTH_NOT_MET"] = "ERR_HEADER_PAX_MIN_BUFFER_LENGTH_NOT_MET";
  ArchiveReadError2["ERR_HEADER_MISSING_POST_PAX_SEGMENT"] = "ERR_HEADER_MISSING_POST_PAX_SEGMENT";
})(ArchiveReadError || (ArchiveReadError = {}));
var ArchiveReader = class _ArchiveReader {
  constructor(bufferIterator) {
    this.bufferIterator = bufferIterator;
    this.mGlobalPaxHeaders = [];
    this.mBufferCache = null;
    this.mOffset = 0;
    this.mHasSyncInput = this.bufferIterator.input instanceof InMemoryAsyncUint8Array;
  }
  static withInput(input) {
    return new _ArchiveReader(new AsyncUint8ArrayIterator(input));
  }
  [Symbol.asyncIterator]() {
    return this;
  }
  get source() {
    return this.bufferIterator.input;
  }
  get globalPaxHeaders() {
    return this.mGlobalPaxHeaders;
  }
  async readAllEntries() {
    const entries = [];
    for await (const entry of this) {
      entries.push(entry);
    }
    return entries;
  }
  async next() {
    const entry = await this.tryParseNextEntry();
    if (entry !== null) {
      return { done: false, value: entry };
    }
    return { done: true, value: null };
  }
  clearBufferCache() {
    this.mBufferCache = null;
    this.mOffset = 0;
  }
  getBufferCacheSlice(start, end) {
    return TarUtility.cloneUint8Array(this.mBufferCache, start, end);
  }
  async tryRequireBufferSize(size) {
    const buffer = await this.requireBufferSize(size);
    return buffer !== null;
  }
  async requireBufferSize(size) {
    while (!this.mBufferCache || this.mBufferCache.byteLength < size) {
      if (!await this.loadNextChunk()) {
        this.clearBufferCache();
        return null;
      }
    }
    return this.mBufferCache;
  }
  async loadNextChunk() {
    const nextChunk = await this.bufferIterator.tryNext();
    if (!nextChunk) {
      return false;
    }
    if (this.mBufferCache) {
      this.mBufferCache = TarUtility.concatUint8Arrays(this.mBufferCache, nextChunk);
    } else {
      this.mBufferCache = nextChunk;
      this.mOffset = 0;
    }
    return true;
  }
  async tryParseNextEntry() {
    const headerParseResult = await this.tryParseNextHeader();
    if (headerParseResult === null) {
      this.clearBufferCache();
      return null;
    }
    const context = this;
    const { header, headerOffset, contentOffset } = headerParseResult;
    const headerByteLength = contentOffset - headerOffset;
    const contentEnd = contentOffset + header.fileSize;
    const offset = headerOffset;
    const nextSectorStart = TarUtility.roundUpSectorOffset(contentEnd);
    let content = null;
    if (this.mHasSyncInput && header.fileSize > 0) {
      if (!await this.tryRequireBufferSize(nextSectorStart)) {
        throw ArchiveReadError.ERR_ENTRY_CONTENT_MIN_BUFFER_LENGTH_NOT_MET;
      }
      content = this.getBufferCacheSlice(contentOffset, contentEnd);
    }
    if (nextSectorStart + Constants.SECTOR_SIZE <= this.mBufferCache.byteLength) {
      this.mBufferCache = this.getBufferCacheSlice(nextSectorStart);
      this.mOffset = 0;
    } else {
      this.mOffset = nextSectorStart;
    }
    return new ArchiveEntry({ header, offset, headerByteLength, content, context });
  }
  async tryParseNextHeader() {
    if (!await this.tryRequireBufferSize(this.mOffset + Constants.HEADER_SIZE)) {
      return null;
    }
    let ustarOffset = TarHeaderUtility.findNextUstarSectorOffset(this.mBufferCache, this.mOffset);
    while (ustarOffset < 0 && this.mBufferCache.byteLength < MAX_LOADED_BYTES && await this.loadNextChunk()) {
      ustarOffset = TarHeaderUtility.findNextUstarSectorOffset(this.mBufferCache, this.mOffset);
    }
    if (ustarOffset < 0) {
      this.clearBufferCache();
      return null;
    }
    let headerOffset = ustarOffset;
    let headerBuffer = this.getBufferCacheSlice(headerOffset, headerOffset + Constants.HEADER_SIZE);
    let ustarHeader = UstarHeader.deserialize(headerBuffer);
    let header = new TarHeader({ ustar: ustarHeader });
    let nextOffset = TarUtility.advanceSectorOffset(headerOffset, this.mBufferCache.byteLength);
    if (ustarHeader.isPaxHeader) {
      const paxHeaderSectorEnd = nextOffset + TarUtility.roundUpSectorOffset(header.fileSize);
      const requiredBufferSize = paxHeaderSectorEnd + Constants.HEADER_SIZE;
      const isGlobalPax = header.isGlobalPaxHeader;
      const preambleHeader = ustarHeader;
      if (!await this.tryRequireBufferSize(requiredBufferSize)) {
        throw ArchiveReadError.ERR_HEADER_PAX_MIN_BUFFER_LENGTH_NOT_MET;
      }
      const paxHeader = PaxHeader.deserialize(this.mBufferCache, nextOffset);
      nextOffset = paxHeaderSectorEnd;
      if (!TarHeaderUtility.isUstarSector(this.mBufferCache, nextOffset)) {
        throw ArchiveReadError.ERR_HEADER_MISSING_POST_PAX_SEGMENT;
      }
      headerOffset = nextOffset;
      headerBuffer = this.getBufferCacheSlice(headerOffset, headerOffset + Constants.HEADER_SIZE);
      ustarHeader = UstarHeader.deserialize(headerBuffer);
      nextOffset = TarUtility.advanceSectorOffsetUnclamped(nextOffset);
      header = new TarHeader({
        ustar: ustarHeader,
        pax: paxHeader,
        preamble: preambleHeader
      });
      if (isGlobalPax) {
        this.mGlobalPaxHeaders.push(header);
      }
    }
    return { header, headerOffset, contentOffset: nextOffset };
  }
};

// node_modules/@obsidize/tar-browserify/archive/archive-writer.js
var ArchiveWriter = class _ArchiveWriter {
  constructor(entries = []) {
    this.entries = entries;
  }
  /**
   * Combines the given array of entries into a single, complete tarball buffer
   */
  static serialize(entries) {
    let outputLength = Constants.TERMINAL_PADDING_SIZE;
    const outputBuffers = [];
    for (const entry of entries) {
      const entryBytes = entry.toUint8Array();
      outputBuffers.push(entryBytes);
      outputLength += entryBytes.byteLength;
    }
    const output = new Uint8Array(outputLength);
    let offset = 0;
    for (const entryBuf of outputBuffers) {
      output.set(entryBuf, offset);
      offset += entryBuf.byteLength;
    }
    return output;
  }
  /**
   * @returns a complete tar buffer from all the currently set tar entries in this instance.
   */
  toUint8Array() {
    return _ArchiveWriter.serialize(this.entries);
  }
  /**
   * Convenience for appending a new entry to the existing `entries` array
   * @returns `this` for operation chaining
   */
  addEntry(entry) {
    this.entries.push(entry);
    return this;
  }
  /**
   * Convenience for appending a new entry to the existing `entries` array.
   * @returns `this` for operation chaining
   */
  addEntryWith(header, content) {
    return this.addEntry(new ArchiveEntry({ headerAttributes: header, content }));
  }
  /**
   * Convenience option for building tarball data
   * @param path - the file name, e.g. './relative/path/to/your/file.txt'
   * @param content - the content of the file (shocker!)
   * @param headerOptions - custom options for this entry
   * @returns `this` for operation chaining
   */
  addTextFile(path, content, headerOptions) {
    return this.addBinaryFile(path, TarUtility.encodeString(content), headerOptions);
  }
  /**
   * Convenience option for building tarball data
   * @param path - the file name, e.g. './relative/path/to/your/file.bin'
   * @param content - the content of the file (shocker!)
   * @param headerOptions - custom options for this entry
   * @returns `this` for operation chaining
   */
  addBinaryFile(path, content, headerOptions = {}) {
    const combinedHeaderOptions = Object.assign({
      fileName: path,
      fileSize: content.byteLength,
      typeFlag: UstarHeaderLinkIndicatorType.NORMAL_FILE
    }, headerOptions);
    return this.addEntryWith(combinedHeaderOptions, content);
  }
  /**
   * Convenience option for building tarball data
   * @param path - the directory name, e.g. './relative/path/to/your/dir'
   * @param headerOptions - custom options for this entry
   * @returns `this` for operation chaining
   */
  addDirectory(path, headerOptions = {}) {
    const combinedHeaderOptions = Object.assign({
      fileName: path,
      typeFlag: UstarHeaderLinkIndicatorType.DIRECTORY
    }, headerOptions);
    return this.addEntryWith(combinedHeaderOptions);
  }
  /**
   * Removes any entries from this writer's cache that meet the given predicate condition.
   * @param predicate - delegate that will return true for any entry that should be removed.
   * @returns `this` for operation chaining
   */
  removeEntriesWhere(predicate) {
    this.entries = this.entries.filter((v) => !predicate(v));
    return this;
  }
  /**
   * Convenience option for cleaning the header of each listed entry.
   * When headers are "cleaned", unknown PAX properties will be removed
   * (e.g. unwanted MacOS "quarantine" headers), and USTAR fields
   * will be normalized (if necessary).
   */
  cleanAllHeaders() {
    for (const entry of this.entries) {
      entry.header.clean();
    }
    return this;
  }
};

// node_modules/@obsidize/tar-browserify/archive/archive.js
var Archive = class _Archive extends ArchiveWriter {
  constructor(entries) {
    super(entries);
  }
  /**
   * Parses an Archive instance from the given buffer, with all entries read into memory.
   * The buffer should come from a complete, uncompressed tar file.
   */
  static async extract(input) {
    const reader = ArchiveReader.withInput(input);
    const entries = await reader.readAllEntries();
    return new _Archive(entries);
  }
  /**
   * Iterate over entries in-place from a given source buffer.
   * The buffer should come from a complete, uncompressed tar file.
   */
  static read(input) {
    return ArchiveReader.withInput(input);
  }
};
export {
  Archive,
  ArchiveEntry,
  ArchiveReadError,
  ArchiveReader,
  ArchiveWriter,
  AsyncUint8ArrayIterator,
  Constants,
  InMemoryAsyncUint8Array,
  PaxHeader,
  PaxHeaderKey,
  PaxHeaderSegment,
  TarHeader,
  TarHeaderUtility,
  TarUtility,
  UstarHeader,
  UstarHeaderField,
  UstarHeaderFieldTransformType,
  UstarHeaderFieldType,
  UstarHeaderLinkIndicatorType
};
//# sourceMappingURL=@obsidize_tar-browserify.js.map
